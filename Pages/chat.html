<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MirAI</title>
    <meta name="description" content="MirAI is a chatbot and personal AI assistant powered by Google Gemini. Get answers, creative ideas, translations, and other help instantly.">
    <meta name="keywords" content="Allwaysever, AI, Artificial Intelligence, Chatbot AI, AI Chatbot, Gemini 2.5 flash, Google Gemini, Gemini API, MirAI">
    <meta name="google-site-verification" content="Ww9spnmeAgguaCwvLVAw-0SV0_ZS-bA7bjNgyWKaeQU"/>
    <meta property="og:title" content="MirAI" />
    <meta property="og:description" content="MirAI is a chatbot and personal AI assistant powered by Google Gemini. Get answers, creative ideas, translations, and other help instantly." />
    <meta property="og:url" content="https://allwaysevermirai.netlify.app/" />
    <meta property="og:image" content="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/MirAI%20Banner.png" />
    <meta property="og:type" content="article" /> <meta property="og:site_name" content="MirAI by Allwaysever" />
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://esm.sh/gh/Allwaysever/MirAI@main/Assets/CSS/MirAIStyle.css">
   <link rel="manifest" href="https://esm.sh/gh/Allwaysever/MirAI@main/Assets/HTML/MirAIPWAm.json">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="MirAI">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1a1a1a">
    <meta name="msapplication-TileColor" content="#1a1a1a">
    <meta name="msapplication-TileImage" content="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">
    <meta name="msapplication-config" content="browserconfig.xml">
    <link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">
    <link rel="mask-icon" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png" color="#1a1a1a">
    <script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
    <script>
        // notif sw onesignal
  window.OneSignalDeferred = window.OneSignalDeferred || [];
  OneSignalDeferred.push(async function(OneSignal) {
    await OneSignal.init({
      appId: "9b77aea2-462f-498d-be06-bc4f75ab7ab7",
      safari_web_id: "web.onesignal.auto.31f2bfbe-48d0-4a72-b7e0-d44022a2d3bb",
      notifyButton: {
        enable: false,
      },
    });
  });
    
// Di dalam script utama (setelah DOMContentLoaded)
let deferredPrompt;

window.addEventListener('beforeinstallprompt', (e) => {
  // Mencegah tampilan prompt otomatis
  e.preventDefault();
  // Simpan event untuk digunakan nanti
  deferredPrompt = e;
  
  // Tampilkan tombol install custom
  showInstallButton();
});

function showInstallButton() {
  const installBtn = document.createElement('button');
  installBtn.id = 'installBtn';
  installBtn.innerHTML = '<a href="https://allwaysevermirai.netlify.app/download"><i class="fas fa-download"></i> Install App</a>';
  installBtn.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #4285f4;
    color: white;
    text-decoration: none;
    border: none;
    padding: 10px 20px;
    border-radius: 25px;
    cursor: pointer;
    z-index: 1000;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  `;
  
  installBtn.addEventListener('click', async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`User response to the install prompt: ${outcome}`);
      deferredPrompt = null;
      installBtn.remove();
    }
  });
  
  document.body.appendChild(installBtn);
}

// Cek jika app sudah diinstall
window.addEventListener('appinstalled', (evt) => {
  console.log('PWA was installed successfully!');
  // Hapus tombol install jika ada
  const installBtn = document.getElementById('installBtn');
  if (installBtn) installBtn.remove();
});

  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('https://cdn.jsdelivr.net/gh/Allwaysever/MirAI@main/Assets/HTML/MirAIPWAsw.js')
        .then(function(registration) {
          console.log('ServiceWorker registered successfully');
        })
        .catch(function(err) {
          console.log('ServiceWorker registration failed: ', err);
        });
    });
  }
  
// Cek apakah service worker terdaftar
navigator.serviceWorker.getRegistrations().then(registrations => {
  console.log('Registered Service Workers:', registrations);
});

// Atau cek spesifik
if ('serviceWorker' in navigator) {
  console.log('Service Worker supported');
  
  navigator.serviceWorker.ready.then(registration => {
    console.log('Service Worker is ready:', registration);
  });
}

// Auto-generate version based on date
function generateVersion(major, minor, patch) {
    const now = new Date();
    const yymmdd = now.getFullYear().toString().slice(-2) + 
                   String(now.getMonth() + 1).padStart(2, '0') + 
                   String(now.getDate()).padStart(2, '0');
    
    return `${major}.${minor}.${patch}.${yymmdd}`;
} 

// Usage
const VERSION = '3.0-Beta5'; // generateVersion(3, 0, 0);
</script>
</head>

<body>
    <div id="splash-screen">
  <div class="splash-content">
    <img src="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Name%20Logo.png" alt="MirAI" class="splash-logo logo-img">
    <div class="loading-bar-container" id="splash-loader">
        <div class="loading-bar"></div>
    </div>
<p style="font-size: 0.5em; color: #aaa; bottom: 5px;">&copy 2025-2026 Allwaysever Project: MirAI</p>
  </div>
</div>

<div id="settingsBtnContainer">
    <button id="settingsBtn">
        <i class="fas fa-bars"></i>
    </button>
</div>

<div id="clearBtnContainer">
    <button id="clearBtn">
        <i class="fas fa-trash-alt"></i>
    </button>
</div>

<div id="connectionStatus">
    <span id="statusDot" class="status-dot"></span>
    <span id="statusLabel" class="status-label"></span>
</div>

<div class="logo-container">
    <img src="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/HI%20new.png" alt="what are we talking about?" class="hi-img">
</div>

<div id="languageSwitcher">
    <select id="langDropdown" class="lang-dropdown">
        <option value="id">üáÆüá© Bahasa Indonesia</option>
        <option value="en">üá∫üá∏ English (US)</option>
        <option value="en-uk">üá¨üáß English (UK)</option>
        <option value="jp">üáØüáµ Êó•Êú¨Ë™û</option>
    </select>
</div>

<div class="chat-container">
    <div id="chatMessages"></div>
</div>

<div id="toolsMenu" class="suggestion-box"></div>

<div id="inputContainer" class="input-container centered">
    <div id="imagePreviewContainer" class="imagePreviewContainer">
       <div class="imagePreviewWrapper">
        <img id="imagePreview" src="" alt="Image Preview" class="imagePreview"">
        <button id="removeImageBtn" class="imgRemoveBtn"><i class="fas fa-times"></i></button>
    </div>
</div>
    
    <div id="suggestionBox" class="suggestion-box"></div>
    <div class="input-box">
        <button id="toolsBtn">
            <i class="fas fa-plus"></i>
        </button>
<button id="uploadImageBtn">
    <i class="fas fa-paperclip"></i>
</button>
<input type="file" id="imageInput" accept="image/*" style="display: none;">
        <textarea id="questionInput" rows="1"></textarea>
        <button id="sendBtn">
            <i class="fas fa-paper-plane"></i>
        </button>
        <button id="stopBtn" style="display: none;">
            <i class="fas fa-stop"></i>
        </button>
    </div>
    <p id="infoText" class="info-text"></p>
</div>

<!-- Settings Panel -->
<div id="settingsPanel">
    <!-- Header -->
    <div class="settings-header">
        <h2 id="settingsHeaderTitle">Pengaturan</h2>
        <button id="backBtn"><i class="fas fa-times"></i></button>
    </div>

    <!-- Body (Scrollable) -->
    <div class="settings-body">
        <div class="settings-content">
            <h3 id="settingsAppearanceTitle">Tampilan</h3>
            <div class="settings-option">
                <p id="settingsThemeText">Pilih preferensi tema Anda:</p>
                <select id="themeSelect">
                    <option value="light" id="themeLightOption">Terang</option>
                    <option value="dark" id="themeDarkOption">Gelap</option>
                </select>
            </div>
            
            <h3 id="settingsAITitle">Persona AI</h3>
            <div class="settings-option">
                <p id="settingsPersonaText">Pilih gaya respons AI:</p>
                <select id="personaSelect">
                    <option value="formal" id="personaFormalOption">Formal & Profesional</option>
                    <option value="default" id="personaDefaultOption">Santai & Bercanda</option>
                    <option value="creative" id="personaCreativeOption">Kreatif & Ekspresif</option>
                    <option value="custom" id="personaCustomOption">Custom Persona</option>
                </select>
                
                <!-- Custom Persona Input -->
                <div id="customPersonaContainer" style="display: none; margin-top: 15px;">
                    <textarea id="customPersonaInput" 
                              class="custom-persona-input" 
                              placeholder="Masukkan prompt custom Anda di sini..."></textarea>
                    <p class="hint-text" id="customPersonaHint">
                        Prompt Anda akan digabungkan dengan: "Anda adalah MirAI, Asisten AI, "
                    </p>
                </div>
            </div>

            <!-- Chat Memory Settings -->
            <h3 id="settingsMemoryTitle">Memori Percakapan</h3>
            <div class="settings-option">
                <p id="settingsMemoryText">Batas maksimal gelembung chat yang disimpan:</p>
                <div class="memory-slider-container">
                    <div class="slider-header">
                        <span id="currentBubbleCount">Gelembung saat ini: 0</span>
                        <span id="maxBubbleLimit">Max: <span id="maxBubbleValue">50</span></span>
                    </div>
                    
                    <input type="range" id="memorySlider" min="25" max="85" step="5" value="50" list="sliderMarkers">
                    <datalist id="sliderMarkers">
                        <option value="25"></option>
                        <option value="40"></option>
                        <option value="55"></option>
                        <option value="70"></option>
                        <option value="85"></option>
                    </datalist>
                    
                    <div class="slider-labels">
                        <span>25</span>
                        <span>40</span>
                        <span>55</span>
                        <span>70</span>
                        <span>85</span>
                    </div>
                    
                    <div class="slider-status">
                        <div id="memoryStatusMessage" class="status-message">
                            Pengaturan akan diterapkan setelah disimpan.
                        </div>
                    </div>
                </div>
            </div>

            <h3 id="settingsApiTitle">Kunci API Google</h3>
            <div class="settings-option">
                <p id="settingsApiText">Masukkan Kunci API kustom Anda:</p>
                <div class="api-key-container">
                    <input type="password" id="apiKeyInput" placeholder="Kosongkan untuk menggunakan kunci default">
                    <i class="fas fa-eye" id="toggleApiKey"></i>
                </div>
            </div>

            <!-- Search Configuration -->
            <h3 id="settingsSearchTitle">Search Configuration</h3>
            <div class="settings-option">
                <div class="engine-info" style="margin-bottom: 15px; padding: 12px 15px; background: linear-gradient(135deg, rgba(66, 133, 244, 0.05), rgba(15, 15, 15, 0.8)); border-radius: var(--srui-radius-md); border: 1px solid rgba(66, 133, 244, 0.15);">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                        <p style="font-size: 0.85em; margin: 0;">
                            <strong><i class="fas fa-magnifying-glass"></i> Search Mode:</strong>
                        </p>
                        <div id="searchModeIndicator" style="font-size: 0.75em; padding: 4px 10px; border-radius: 20px; background: rgba(66, 133, 244, 0.15); color: #4285f4; border: 1px solid rgba(66, 133, 244, 0.3);">
                            Checking...
                        </div>
                    </div>
                    <div id="searchModeInfo" style="font-size: 0.75em; margin: 0; color: var(--srui-text-secondary); line-height: 1.5;">
                        Loading search configuration...
                    </div>
                    <p style="font-size: 0.75em; margin: 10px 0 0 0; color: var(--srui-text-secondary);">
                        ‚Ä¢ <strong>External Search:</strong> Uses API engines (requires API keys)
                        <br>‚Ä¢ <strong>AI Knowledge Base:</strong> Uses AI's training data only (no API needed)
                    </p>
                </div>
                
                <p style="font-size: 0.8em; color: var(--srui-text-tertiary);" id="searchConfigDesc">Configure external search engines for /search command</p>
                <div class="search-engine-config">
                    <div class="engine-option">
                        <label>
                            <input type="checkbox" id="enableSearchAPI" checked>
                            SearchAPI.io (Default)
                        </label>
                        <input type="password" id="searchapiApiKey" placeholder="SearchAPI.io Key" style="width: 70%;" class="api-key-input">
                        <i class="fas fa-eye toggle-api-eye" data-target="searchapiApiKey"></i>
                    </div>
                    
                    <div class="engine-option">
                        <label>
                            <input type="checkbox" id="enableGoogleSearch" checked>
                            Google Search (Secondary)
                        </label>
                        <input type="password" id="googleApiKey" placeholder="Google API Key" style="width: 70%;" class="api-key-input">
                        <input type="text" id="googleCx" placeholder="Search Engine ID" style="width: 70%;">
                        <i class="fas fa-eye toggle-api-eye" data-target="googleApiKey"></i>
                    </div>
                    
                    <div class="engine-option">
                        <label>
                            <input type="checkbox" id="enableDuckDuckGo" checked>
                            DuckDuckGo (No API needed)
                        </label>
                    </div>
                    
                    <div class="engine-option">
                        <label>
                            <input type="checkbox" id="enableWikipedia" checked>
                            Wikipedia (No API needed)
                        </label>
                    </div>
                    
                    <p class="hint-text">
                        Get SearchAPI.io key from: <a href="https://www.searchapi.io" target="_blank" style="color: #ffce00;">searchapi.io</a><br>
                        Free tier available with 100 searches/month
                    </p>
                    
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button id="testSearchBtn" class="settings-credits-btn" style="background: var(--srui-info);">
                            <i class="fas fa-search"></i> Test Search
                        </button>
                        <button id="clearSearchCacheBtn" class="settings-credits-btn" style="background: var(--srui-error);">
                            <i class="fas fa-trash"></i> Clear Cache
                        </button>
                    </div>
                </div>
            </div>

            <h3 id="settingsBackupTitle">Backup & Restore</h3>
            <div class="settings-option">
                <p style="font-size: 0.8em; color: var(--srui-text-tertiary);" id="backupDescText">Save or move your chat history via JSON file.</p>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button id="exportBtn" class="settings-credits-btn" style="background: var(--srui-success);">
                        <i class="fas fa-download"></i> Export
                    </button>
                    <button id="importBtn" class="settings-credits-btn" style="background: var(--srui-warning); color: var(--srui-accent-text);">
                        <i class="fas fa-upload"></i> Import
                    </button>
                </div>
                <input type="file" id="importFileInput" accept=".json,.mdf,.medf" style="display: none;">
            </div>
            
            <div class="settings-about">
                <h3 id="settingsAboutTitle">Tentang Aplikasi</h3>
                <p id="settingsVersionText"></p>
                <p id="settingsAuthorText">Dikembangkan oleh Allwaysever</p>
                <p><a href="https://allwaysevermirai.netlify.app/about" target="_blank" id="githubLink"><i class="fas fa-info-circle"></i> Tentang MirAI</a></p>
                <p><a href="https://github.com/Allwaysever/MirAI/blob/main/LICENSE" id="licenseLink" target="_blank"><i class="fas fa-file-contract"></i> Lisensi</a></p>
                <p><a href="help/index.html" id="helpLink" target="_self"><i class="fas fa-question-circle"></i> Pusat Bantuan</a></p>
                <p style="display: inline-block; padding: 10px 20px; background-color: transparent; text-align: center; border-radius: 999px; cursor: pointer; transition: background-color 0.3s; border: 1px solid #ffce00;"><a href="https://allwaysevermirai.netlify.app/releasenote" target="_blank">Release notes</a></p>
                <p style="display: inline-block; padding: 10px 20px; background-color: transparent; text-align: center; border-radius: 999px; cursor: pointer; transition: background-color 0.3s; border: 1px solid #ffce00;"><a href="https://allwaysevermirai.netlify.app/donate" target="_blank">Donate us</a></p>
                <div class="gemini-container">
                    <a href="https://deepmind.google/models/gemini/flash/" target="_blank">
                        <img src="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Gemini%202.5%20Flash%20Logo.png" alt="Google Gemini 2.5 Flash" class="gemini-logo">
                    </a>
                </div>
                <p id="termsText" style="margin-top: 20px; font-size: 0.8em; color: var(--srui-text-secondary);">
                    Dengan menggunakan MirAI, Anda menyetujui <a href="T&C/index.html" target="_blank">Syarat & Ketentuan</a>.
                </p>
            </div>
        </div>
    </div>

    <!-- Footer (Fixed) -->
    <div class="settings-footer">
        <button id="saveApiBtn" class="settings-credits-btn">
            <i class="fas fa-save"></i> Simpan Pengaturan
        </button>
    </div>
</div>

<div id="customConfirmOverlay">
    <div id="customConfirmBox">
        <p id="customConfirmMessage"></p>
        <div class="custom-confirm-buttons">
            <button id="confirmBtnYes"></button>
            <button id="confirmBtnNo"></button>
        </div>
    </div>
</div>

<script>
    const DEFAULT_API_KEY = 'AIzaSyBclOlr7UNm1Leoj83fB9uJR7Jt6qQRphA';

    // === SEARCH CONFIGURATION ===
    const SEARCH_CONFIG = {
        engines: {
            searchapi: {
                apiKey: '',  // Will be loaded from localStorage
                endpoint: 'https://www.searchapi.io/api/v1/search',
                enabled: false, // ‚≠ê‚≠ê DEFAULTS TO FALSE FOR NEW USERS
                engine: 'google' // You can change to 'bing', 'yahoo', etc.
            },
            google: {
                apiKey: '',  // Will be loaded from localStorage
                cx: '',      // Custom Search Engine ID
                endpoint: 'https://www.googleapis.com/customsearch/v1',
                enabled: false // ‚≠ê‚≠ê DEFAULTS TO FALSE FOR NEW USERS
            },
            duckduckgo: {
                endpoint: 'https://api.duckduckgo.com/',
                format: 'json',
                enabled: false // ‚≠ê‚≠ê DEFAULTS TO FALSE FOR NEW USERS
            },
            wikipedia: {
                endpoint: 'https://en.wikipedia.org/w/api.php',
                enabled: false // ‚≠ê‚≠ê DEFAULTS TO FALSE FOR NEW USERS
            }
        },
        
        defaultEngine: 'searchapi',
        resultsPerPage: 5,
        timeout: 10000,
        cacheDuration: 3600000
    };

    // Cache untuk hasil search
    let searchCache = new Map();

    // === SISTEM API KEY TERENKRIPSI (.medf) dengan Authenticity Header ===
    const MEDF_PROCESSOR = {
        async loadEncryptedApiKey() {
            try {
                const response = await fetch('config.medf');
                if (!response.ok) {
                    console.log('config.medf not found, using default');
                    return DEFAULT_API_KEY;
                }
                
                const buffer = await response.arrayBuffer();
                const savedCode = localStorage.getItem('miraiConfigCode');
                let code = MEDF_PROCESSOR.DEFAULT_CODE;
                
                if (savedCode) {
                    try {
                        code = parseInt(savedCode);
                    } catch (e) {
                        console.warn('Invalid code, using default');
                    }
                }
                
                console.log('üîç Loading and verifying config.medf...');
                const apiKey = await MEDF_PROCESSOR.extractApiKeyFromConfig(buffer, code);
                console.log('‚úÖ API Key berhasil didekripsi dan diverifikasi dari config.medf');
                return apiKey;
                
            } catch (error) {
                console.error('‚ùå Gagal memuat config.medf:', error);
                
                let errorMessage = 'Failed to read config.medf\n\n';
                
                if (error.message.includes('Tidak Otentik') || error.message.includes('signature')) {
                    errorMessage += '‚ö†Ô∏è The config.medf file is not authentic or corrupt!\n';
                    errorMessage += 'The file may have been modified or may not be an official MirAI file.\n\n';
                } else {
                    errorMessage += 'Maybe the calculation code is wrong or the file is corrupted.\n\n';
                }
                
                errorMessage += 'Want to enter manual calculation code?';
                
                if (confirm(errorMessage)) {
                    const userCode = prompt('Enter the calculation code for config.medf:');
                    if (userCode) {
                        try {
                            const code = parseInt(userCode);
                            localStorage.setItem('miraiConfigCode', code);
                            
                            const response = await fetch('config.medf');
                            const buffer = await response.arrayBuffer();
                            const apiKey = await MEDF_PROCESSOR.extractApiKeyFromConfig(buffer, code);
                            return apiKey;
                        } catch (e) {
                            console.error('Invalid code:', e);
                        }
                    }
                }
                
                return DEFAULT_API_KEY;
            }
        },
        
        async extractApiKeyFromConfig(fileBuffer, code) {
            if (window.MEDFProcessor && window.MEDFProcessor.extractApiKeyFromConfig) {
                return await window.MEDFProcessor.extractApiKeyFromConfig(fileBuffer, code);
            }
            
            try {
                const password = this.generatePasswordFromCode(code);
                const encoder = new TextEncoder();
                const salt = fileBuffer.slice(0, 16);
                const iv = fileBuffer.slice(16, 28);
                const encryptedData = fileBuffer.slice(28);
                
                console.log('üîê Decrypting with authenticity check...');
                
                const passwordKey = await crypto.subtle.importKey(
                    "raw", 
                    encoder.encode(password), 
                    "PBKDF2", 
                    false, 
                    ["deriveKey"]
                );
                
                const key = await crypto.subtle.deriveKey(
                    { 
                        name: "PBKDF2", 
                        salt: salt, 
                        iterations: 100000, 
                        hash: "SHA-256" 
                    },
                    passwordKey, 
                    { name: "AES-GCM", length: 256 }, 
                    false, 
                    ["decrypt"]
                );
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv }, 
                    key, 
                    encryptedData
                );
                
                const decryptedText = new TextDecoder().decode(decrypted);
                const data = JSON.parse(decryptedText);
                
                console.log('üîç Validating file authenticity...');
                
                if (!data._signature || !data._signature.headerText || !data._signature.headerCode) {
                    throw new Error("‚ùå The .medf file does not have an authenticity signature!");
                }
                
                let isValid = false;
                
                if (window.MEDFProcessor && window.MEDFProcessor.validateSignature) {
                    isValid = window.MEDFProcessor.validateSignature(
                        data._signature.headerText, 
                        data._signature.headerCode
                    );
                } else {
                    const HEADER_TEXT = "{MirAI Encrypted Data Files v1.0 By Allwaysever}";
                    
                    if (data._signature.headerText !== HEADER_TEXT) {
                        throw new Error("‚ùå Header text is incorrect!");
                    }
                    
                    let expectedCode = '';
                    for (let i = 0; i < HEADER_TEXT.length; i++) {
                        const charCode = HEADER_TEXT.charCodeAt(i);
                        const transformedCode = (charCode + 2) * 3;
                        expectedCode += transformedCode.toString().padStart(4, '0');
                    }
                    
                    if (data._signature.headerCode !== expectedCode) {
                        throw new Error("‚ùå Header code is incorrect!");
                    }
                    
                    isValid = true;
                }
                
                if (!isValid) {
                    throw new Error("‚ùå .medf File Is Inauthentic or Corrupt!");
                }
                
                console.log('‚úÖ File verified as authentic!');
                return data.apiKey || DEFAULT_API_KEY;
                
            } catch (e) {
                console.error('Decryption error:', e);
                
                if (e.message.includes('Tidak Otentik')) {
                    throw new Error("‚ùå .medf File Is Not Authentic or Corrupt!\nThe file may have been modified or is not an official MirAI file.");
                } else if (e.message.includes('signature')) {
                    throw new Error("‚ùå The file does not have a valid authenticity signature!");
                } else {
                    throw new Error("Incorrect calculation code or corrupted file");
                }
            }
        },
        
        generatePasswordFromCode(code) {
            let num = Math.abs(code);
            let result = '';
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            
            while (num > 0) {
                const remainder = num % 26;
                result = alphabet[remainder] + result;
                num = Math.floor(num / 26);
            }
            
            if (!result) result = 'MIRAI';
            const checksum = code.toString().split('').reduce((a, b) => a + parseInt(b), 0) % 26;
            result += alphabet[checksum];
            
            return result;
        },
        
        async validateBackupFile(fileBuffer, password) {
            try {
                const encoder = new TextEncoder();
                const salt = fileBuffer.slice(0, 16);
                const iv = fileBuffer.slice(16, 28);
                const encryptedData = fileBuffer.slice(28);
                
                const passwordKey = await crypto.subtle.importKey(
                    "raw", 
                    encoder.encode(password), 
                    "PBKDF2", 
                    false, 
                    ["deriveKey"]
                );
                
                const key = await crypto.subtle.deriveKey(
                    { 
                        name: "PBKDF2", 
                        salt: salt, 
                        iterations: 100000, 
                        hash: "SHA-256" 
                    },
                    passwordKey, 
                    { name: "AES-GCM", length: 256 }, 
                    false, 
                    ["decrypt"]
                );
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv }, 
                    key, 
                    encryptedData
                );
                
                const decryptedText = new TextDecoder().decode(decrypted);
                const data = JSON.parse(decryptedText);
                
                if (!data._signature) {
                    console.warn('‚ö†Ô∏è Backup file does not have signature');
                    return { isValid: false, message: 'File does not have authenticity signature' };
                }
                
                const HEADER_TEXT = "{MirAI Encrypted Data Files v1.0 By Allwaysever}";
                
                if (data._signature.headerText !== HEADER_TEXT) {
                    return { isValid: false, message: 'Signature header text is invalid' };
                }
                
                let expectedCode = '';
                for (let i = 0; i < HEADER_TEXT.length; i++) {
                    const charCode = HEADER_TEXT.charCodeAt(i);
                    const transformedCode = (charCode + 2) * 3;
                    expectedCode += transformedCode.toString().padStart(4, '0');
                }
                
                if (data._signature.headerCode !== expectedCode) {
                    return { isValid: false, message: 'Signature header code is invalid' };
                }
                
                return { 
                    isValid: true, 
                    message: '‚úÖ Backup file verified as authentic',
                    data: data 
                };
                
            } catch (error) {
                console.error('Validation error:', error);
                return { 
                    isValid: false, 
                    message: 'Failed to validate file: ' + error.message 
                };
            }
        },
        
        DEFAULT_CODE: 271828,
        HEADER_TEXT: "{MirAI Encrypted Data Files v1.0 By Allwaysever}",
        
        generateHeaderCode(text) {
            let code = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                const transformedCode = (charCode + 2) * 3;
                code += transformedCode.toString().padStart(4, '0');
            }
            return code;
        },
        
        countPublicApiBubbles: () => window.MEDFProcessor?.countPublicApiBubbles?.() || 0,
        incrementPublicApiBubbles: () => window.MEDFProcessor?.incrementPublicApiBubbles?.() || 0,
        resetPublicApiBubbles: () => window.MEDFProcessor?.resetPublicApiBubbles?.() || null,
        PUBLIC_API_LIMITS: window.MEDFProcessor?.PUBLIC_API_LIMITS || { MAX_BUBBLES_WARNING: 10, MAX_BUBBLES_BLOCK: 12 }
    };

// === FUNGSI LOAD SEARCH CONFIG DARI ENCRYPTED FILE ===
function loadSearchConfigFromEncrypted() {
    console.log('üîç Loading search configuration from encrypted file...');
    
    // Cek jika ada MEDFProcessor yang sudah dimodifikasi dengan getSearchKeys
    if (window.MEDFProcessor && window.MEDFProcessor.getSearchKeys) {
        try {
            const searchKeys = window.MEDFProcessor.getSearchKeys();
            console.log('‚úÖ Search keys loaded from encrypted file:', searchKeys);
            
            // Update SEARCH_CONFIG dengan keys dari encrypted file
            if (searchKeys && typeof searchKeys === 'object') {
                Object.keys(searchKeys).forEach(key => {
                    if (SEARCH_CONFIG.engines[key]) {
                        SEARCH_CONFIG.engines[key] = {
                            ...SEARCH_CONFIG.engines[key],
                            ...searchKeys[key]
                        };
                        
                        console.log(`‚úÖ Updated ${key} config:`, {
                            hasApiKey: !!searchKeys[key].apiKey
                        });
                    }
                });
                
                // Log hasil
                console.log('üîÑ SEARCH_CONFIG setelah update:', {
                    searchapi: {
                        hasApiKey: !!SEARCH_CONFIG.engines.searchapi.apiKey,
                        apiKeyPreview: SEARCH_CONFIG.engines.searchapi.apiKey ? 
                            SEARCH_CONFIG.engines.searchapi.apiKey.substring(0, 10) + '...' : 'empty',
                        enabled: SEARCH_CONFIG.engines.searchapi.enabled
                    },
                    google: {
                        hasApiKey: !!SEARCH_CONFIG.engines.google.apiKey,
                        apiKeyPreview: SEARCH_CONFIG.engines.google.apiKey ? 
                            SEARCH_CONFIG.engines.google.apiKey.substring(0, 10) + '...' : 'empty',
                        hasCx: !!SEARCH_CONFIG.engines.google.cx,
                        cxPreview: SEARCH_CONFIG.engines.google.cx ? 
                            SEARCH_CONFIG.engines.google.cx.substring(0, 10) + '...' : 'empty',
                        enabled: SEARCH_CONFIG.engines.google.enabled
                    }
                });
                
            } else {
                console.warn('‚ö†Ô∏è No search keys found in encrypted file');
            }
            
        } catch (error) {
            console.error('‚ùå Failed to load search config from encrypted file:', error);
        }
    } else {
        console.warn('‚ö†Ô∏è MEDFProcessor.getSearchKeys not available, using default/search config');
        // Coba load dari localStorage sebagai fallback
        loadSearchConfigFromLocalStorage();
    }
}

// Fallback function untuk load dari localStorage
function loadSearchConfigFromLocalStorage() {
    const savedSearchConfig = localStorage.getItem('miraiSearchConfig');
    if (savedSearchConfig) {
        try {
            const config = JSON.parse(savedSearchConfig);
            Object.keys(config).forEach(key => {
                if (SEARCH_CONFIG.engines[key]) {
                    SEARCH_CONFIG.engines[key] = { ...SEARCH_CONFIG.engines[key], ...config[key] };
                }
            });
            console.log('‚úÖ Search config loaded from localStorage');
        } catch (e) {
            console.error('Error loading search config from localStorage:', e);
        }
    }
}

    let currentApiKey = DEFAULT_API_KEY;
    let isUsingPublicApi = false;

    // Deteksi model dan mode PWA
    const urlParams = new URLSearchParams(window.location.search);
    const isBeta = urlParams.has('betamodel');
    const isPWA = urlParams.has('pwa');
    const model = isBeta ? 'gemini-3-flash-preview' : 'gemini-2.5-flash';
    console.log(`Mode yang aktif: ${isBeta ? 'Beta (3 Flash Preview)' : 'Stable (2.5 Flash)'}`);

    const faqDatabase = {
        "changelog": "# Changelog\n\n Check this project's [github repository](https://github.com/Allwaysever/MirAI/blob/main/CHANGELOG.md) for changelogs information.",
        "donate": "# Donate\n\n Please donate to add features and improve AI capabilities. [Buy us a DiamondStars](https://trakteer.id/Allwaysever)",
        "fullmd": "# Heading 1\n\n## Heading 2\n\n### Heading 3\n\n#### Heading 4\n\n##### Heading 5\n\n###### Heading 6\n\nIni **teks tebal** dan ini *teks miring* dan ini ***teks tebal miring*** dan ~~coret~~.\n\nIni [link](https://example.com) dan ini ![gambar](https://example.com/img.jpg).\n\nIni `kode inline`.\n\n```javascript\nconsole.log('code block');\nfunction test() {\n    return 'hello';\n}\n```\n\n```python\nprint('code block lain')\n```\n\n> Ini blockquote.\n>> Nested blockquote.\n\n- Unordered list item 1\n- Unordered list item 2\n  - Nested item 2.1\n  - Nested item 2.2\n- Unordered list item 3\n\n1. Ordered list item 1\n2. Ordered list item 2\n   1. Nested ordered 2.1\n   2. Nested ordered 2.2\n3. Ordered list item 3\n\n---\n\n***\n\n___\n\n| Tabel Header 1 | Tabel Header 2 | Tabel Header 3 |\n|----------------|----------------|----------------|\n| Cell 1         | Cell 2         | Cell 3         |\n| *Italic*       | **Bold**       | `Code`         |\n\n[^1]: Ini footnote.\n\nIni referensi footnote[^1].\n\n~~Ini coret~~.\n\n**Bold dengan underscore** dan __bold underscore__.\n\n*Italic dengan underscore* dan _italic underscore_.\n\n` ``backtick dalam kode`` `\n\n- [ ] Checklist belum centang\n- [x] Checklist sudah centang\n\n\\*Escape karakter asterisk\\*\n\n\\`Escape backtick\\`\n\nH~2~O (subscript) dan X^2^ (superscript).\n\n==highlight==\n\n:joy: emoji :smile:\n\n<!-- Ini komentar HTML -->\n\n[Link referensi][1]\n\n[1]: https://example.com\n\n```\nplain text code block tanpa bahasa\n```\n\nTerminal:\n\n```bash\n$ npm install\n$ npm start\n```\n\n**Daftar campur:**\n- Item 1\n  1. Sub ordered 1\n  2. Sub ordered 2\n- Item 2\n\n### Tabel kompleks:\n| Left align | Center align | Right align |\n| :--- | :---: | ---: |\n| left | center | right |\n| data | data | data |\n\n**Auto link:** <https://google.com>\n\n**Email:** <email@example.com>\n\n**Horizontal rule dengan asterisk:**\n\n***\n\n**Escape semua:** \\*\\*bold\\*\\* \\*italic\\* \\`code\\`\n\nIni adalah paragraf yang sangat panjang yang harusnya akan membentuk satu paragraf utuh meskipun ditulis dalam beberapa baris dalam kode karena markdown akan menganggapnya sebagai satu paragraf selama tidak ada baris kosong di antaranya. Ini akan terus berlanjut sampai akhir.\n\nDan ini paragraf baru.\n\n    Indented code block dengan spasi.\n\n```mermaid\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n```\n\n$$ \\LaTeX $$ math: $x^2 + y^2 = z^2$\n\n$$\\nblock math\\n$$\n\nColon untuk definition list:\n\nTerm 1\n: Definition 1\n\nTerm 2\n: Definition 2\n\n**Task list lain:**\n- [ ] Task 1\n- [x] Task 2 selesai\n- [ ] Task 3\n\n~~Multiple\nlines\ncoret~~\n\n**Bold\nmultiline**\n\nEnd.",
   };

    const uiStrings = {
        'id': {
            offlineTitle: 'Koneksi Internet Terputus',
            offlineText: 'Silakan periksa koneksi WiFi atau data seluler Anda, lalu coba kembali.',
            retryButton: 'Coba Lagi',
            inputPlaceholder: 'Ketik pertanyaan Anda di sini...',
            copyFeedback: 'Teks berhasil disalin!',
            langSwitchFeedback: 'Bahasa telah diubah ke',
            errorAPI: 'Terjadi kesalahan. Silakan muat ulang atau coba beberapa saat lagi.\n\nHmm... sepertinya kunci API ini telah terkena batas penggunaan. Jika Anda masih menggunakan kunci API bawaan, mohon segera ganti dengan kunci API pribadi Anda. Silakan cek tutorialnya di [Halaman GitHub MirAI](https://github.com/Allwaysever/MirAI?tab=readme-ov-file#%EF%B8%8F-setup-using-your-own-api-key).',
            errorFallback: 'Maaf, jawaban tidak ditemukan. Coba gunakan kata kunci yang berbeda.',
            errorConnection: 'Koneksi internet tidak tersedia. Mohon periksa kembali.',
            checkingConnection: 'Memeriksa koneksi internet...',
            copySuffix: '\n\n-- Dihasilkan oleh MirAI',
            infoText: 'Informasi yang dihasilkan AI mungkin tidak akurat. Verifikasi kembali fakta penting.',
            settingsHeaderTitle: 'Pengaturan',
            settingsAppearanceTitle: 'Tampilan',
            settingsThemeText: 'Pilih preferensi tema Anda:',
            themeLightOption: 'Terang',
            themeDarkOption: 'Gelap',
            settingsAITitle: 'Persona AI',
            settingsPersonaText: 'Pilih gaya respons AI:',
            personaFormalOption: 'Formal & Profesional',
            personaDefaultOption: 'Santai & Bercanda',
            personaCreativeOption: 'Kreatif & Ekspresif',
            personaCustomOption: 'Custom Persona',
            customPersonaHint: 'Prompt Anda akan digabungkan dengan: "Anda adalah MirAI, Asisten AI, "',
            customPersonaPlaceholder: 'Masukkan prompt custom Anda di sini...',
            settingsMemoryTitle: 'Memori Percakapan',
            settingsMemoryText: 'Batas maksimal gelembung chat yang disimpan:',
            settingsMemoryCurrent: 'Gelembung saat ini: ',
            settingsMemoryMax: 'Maks: ',
            settingsMemoryHint: 'Pengaturan akan diterapkan setelah disimpan.',
            settingsMemoryWarning: 'Catatan: Akan menghapus {count} gelembung lama saat disimpan.',
            settingsMemorySuccess: 'Memori diperbarui! Menyimpan {current}/{max} gelembung.',
            settingsAboutTitle: 'Tentang Aplikasi',
            settingsVersionText: `Versi: v${VERSION}`,
            settingsAuthorText: 'Dikembangkan oleh Allwaysever',
            githubLink: 'Tentang MirAI',
            licenseLink: 'Lisensi',
            helpLink: 'Pusat Bantuan',
            termsText: 'Dengan menggunakan MirAI, Anda menyetujui <a href="T&C/index.html" target="_blank">Syarat & Ketentuan</a>.',
            personaDefaultPrompt: 'Anda adalah MirAI, asisten AI yang santai dan suka bercanda. Jawab semua pertanyaan dengan gaya yang ramah, sedikit humor, namun tetap informatif.',
            personaFormalPrompt: 'Anda adalah MirAI, asisten AI profesional. Berikan jawaban yang terstruktur, akurat, dan menggunakan bahasa formal.',
            personaCreativePrompt: 'Anda adalah MirAI, asisten AI yang kreatif. Berikan jawaban yang unik, imajinatif, dan ekspresif untuk setiap pertanyaan.',
            personaCustomPrompt: '',
            placeholderMessages: ['Ajukan pertanyaan apa pun.', 'Butuh bantuan untuk ide?', 'Minta terjemahan atau ringkasan.', 'Bagaimana saya bisa membantu?'],
            onlineStatus: 'Terhubung',
            offlineStatus: 'Terputus',
            settingsApiTitle: 'Kunci API Google',
            settingsApiText: 'Masukkan Kunci API kustom Anda:',
            apiKeySaved: 'Kunci API berhasil disimpan.',
            apiKeyRemoved: 'Kunci API dihapus. Menggunakan kunci default.',
            dateTimeContextPrompt: '[{dateTime}]:',
            confirmClearMessage: 'Apakah Anda yakin ingin menghapus riwayat percakapan ini? Tindakan ini tidak dapat diurungkan.',
            confirmClearYes: 'Ya, Hapus',
            confirmClearNo: 'Batal',
            pageTitle: 'MirAI | Asisten AI Anda',
            saveApiKeyBtn: 'Simpan',
            apiKeyPlaceholder: 'Kosongkan untuk menggunakan kunci default',
            settingsBackupTitle: 'Backup & Pulihkan',
            backupDescText: 'Simpan atau pindahkan riwayat chat kamu lewat file JSON.',
            exportBtnText: 'Export',
            importBtnText: 'Import',
            importSuccessText: 'Backup berhasil dipulihkan! Aplikasi akan dimuat ulang.',
            importErrorText: 'Waduh, filenya rusak atau bukan format backup MirAI! üóø',
            installBtnText: 'Install App',
            invalidImageText: 'Silakan unggah file gambar (jpeg, png, webp).',
            betaModelActive: '#3FlashPreviewMode',
            slashCmdSearchTitle: 'Cari',
            slashCmdSearchDesc: '/search [kata kunci pencarian]',
            slashCmdTranslateTitle: 'Terjemahkan',
            slashCmdTranslateDesc: '/translate [teks] to [bahasa]',
            slashCmdSummarizeTitle: 'Ringkas',
            slashCmdSummarizeDesc: '/summarize [teks panjang]',
            slashCmdRephraseTitle: 'Ubah Kalimat',
            slashCmdRephraseDesc: '/rephrase [teks] as [gaya]',
            slashCmdIdeateTitle: 'Buat Ide',
            slashCmdIdeateDesc: '/ideate [jumlah] ideas for [topik]',
            slashCmdFixTitle: 'Perbaiki',
            slashCmdFixDesc: '/fix [teks yang perlu diperbaiki]',
            slashCmdExplainTitle: 'Jelaskan',
            slashCmdExplainDesc: '/explain [konsep] like I\'m [audiens]',
            slashCmdCodeTitle: 'Buat Kode',
            slashCmdCodeDesc: '/code a [bahasa pemrograman] function to [deskripsi]',
            slashErrorInvalidFormat: 'Error: Format tidak valid.',
            slashErrorInvalidFormatTranslate: 'Error: Format tidak valid. Gunakan /translate [teks] to [bahasa]',
            slashErrorInvalidFormatRephrase: 'Error: Format tidak valid. Gunakan /rephrase [teks] as [gaya]',
            slashErrorInvalidFormatIdeate: 'Error: Format tidak valid. Gunakan /ideate [jumlah] ideas for [topik]',
            slashErrorInvalidFormatExplain: 'Error: Format tidak valid. Gunakan /explain [konsep] like I\'m [audiens]',
            slashErrorInvalidFormatCode: 'Error: Format tidak valid. Gunakan /code a [bahasa] function to [deskripsi]',
            slashErrorInvalidFormatSearch: 'Error: Format tidak valid. Gunakan /search [kata kunci]',
            slashErrorUnknownCommand: 'Error: Perintah tidak dikenal.',
            confirmBtnYes: 'Ya, Hapus',
            confirmBtnNo: 'Batal',
            copyFeedback: 'Teks berhasil disalin!',
            pwaInstalledText: 'PWA was installed successfully!',
            apiLimitError: 'Hmm... sepertinya kunci API ini telah terkena batas penggunaan. Jika Anda masih menggunakan kunci API bawaan, mohon segera ganti dengan kunci API pribadi Anda.',
            settingsSearchTitle: 'Konfigurasi Pencarian',
            searchConfigDesc: 'Konfigurasi mesin pencari eksternal untuk perintah /search',
            testSearchBtn: 'Tes Pencarian',
            clearSearchCacheBtn: 'Hapus Cache',
            searchTestResult: 'Hasil tes pencarian untuk "test": ',
            searchCacheCleared: 'Cache pencarian berhasil dihapus!',
            searchEngineNotConfigured: 'Mesin pencari tidak dikonfigurasi',
            searchExample1: '/search artificial intelligence',
            searchExample2: '/search machine learning [engine:wikipedia]',
            searchExample3: '/search OpenAI [type:news] [results:3]',
            searchModeExternal: 'Mode Pencarian Eksternal',
            searchModeAI: 'Mode Basis Pengetahuan AI',
            searchModeDescExternal: '/search menggunakan mesin pencari eksternal',
            searchModeDescAI: '/search menggunakan data pelatihan AI',
            firstVisitSearchInfo: 'Kunjungan pertama: Semua mesin pencari dinonaktifkan secara default. Aktifkan di Pengaturan jika diperlukan.'
        },
        'en': {
            offlineTitle: 'Internet Connection Lost',
            offlineText: 'Please check your WiFi or cellular data connection, then try again.',
            retryButton: 'Retry',
            inputPlaceholder: 'Type your question here...',
            copyFeedback: 'Text copied to clipboard!',
            langSwitchFeedback: 'Language has been changed to',
            errorAPI: 'An error occurred. Please reload the page or try again shortly.\n\nHmm... it seems that this API key has reached its usage limit. If you are still using the default API key, please replace it with your personal API key immediately. Please check the tutorial on the [MirAI GitHub page](https://github.com/Allwaysever/MirAI?tab=readme-ov-file#%EF%B8%8F-setup-using-your-own-api-key).',
            errorFallback: 'Sorry, no answer was found. Please try different keywords.',
            errorConnection: 'Internet connection is unavailable. Please check and try again.',
            checkingConnection: 'Checking internet connection...',
            copySuffix: '\n\n-- Generated by MirAI',
            infoText: 'AI-generated information may be inaccurate. Please verify important facts.',
            settingsHeaderTitle: 'Settings',
            settingsAppearanceTitle: 'Appearance',
            settingsThemeText: 'Select your theme preference:',
            themeLightOption: 'Light',
            themeDarkOption: 'Dark',
            settingsAITitle: 'AI Persona',
            settingsPersonaText: 'Choose the AI\'s response style:',
            personaFormalOption: 'Formal & Professional',
            personaDefaultOption: 'Chill & joking',
            personaCreativeOption: 'Creative & Expressive',
            personaCustomOption: 'Custom Persona',
            customPersonaHint: 'Your prompt will be combined with: "You are MirAI, an AI Assistant, "',
            customPersonaPlaceholder: 'Enter your custom prompt here...',
            settingsMemoryTitle: 'Chat Memory',
            settingsMemoryText: 'Maximum chat bubbles to store:',
            settingsMemoryCurrent: 'Current bubbles: ',
            settingsMemoryMax: 'Max: ',
            settingsMemoryHint: 'Settings will be applied after saving.',
            settingsMemoryWarning: 'Note: Will delete {count} old bubbles when saved.',
            settingsMemorySuccess: 'Memory updated! Keeping {current}/{max} bubbles.',
            settingsAboutTitle: 'About',
            settingsVersionText: `Version: v${VERSION}`,
            settingsAuthorText: 'Developed by Allwaysever',
            githubLink: 'About MirAI',
            licenseLink: 'License',
            helpLink: 'Help Center',
            termsText: 'By using MirAI, you agree to the <a href="T&C/index.html" target="_blank">Terms & Conditions</a>.',
            personaDefaultPrompt: 'You are MirAI, a relaxed and humorous AI assistant. Answer all questions in a friendly style, with a bit of humor, while remaining informative.',
            personaFormalPrompt: 'You are MirAI, a professional AI assistant. Provide well-structured, accurate, and formal responses.',
            personaCreativePrompt: 'You are MirAI, a creative AI assistant. Provide unique, imaginative, and expressive answers to every query.',
            personaCustomPrompt: '',
            placeholderMessages: ['Ask any question.', 'Need help with an idea?', 'Request a translation or summary.', 'How can I assist you?'],
            onlineStatus: 'Connected',
            offlineStatus: 'Disconnected',
            settingsApiTitle: 'Google API Key',
            settingsApiText: 'Enter your custom API Key:',
            apiKeySaved: 'API Key saved successfully.',
            apiKeyRemoved: 'API Key removed. Using default key.',
            dateTimeContextPrompt: '[{dateTime}]:',
            confirmClearMessage: 'Are you sure you want to delete this chat history? This action cannot be undone.',
            confirmClearYes: 'Yes, Delete',
            confirmClearNo: 'Cancel',
            pageTitle: 'MirAI | Your AI Assistant',
            saveApiKeyBtn: 'Save',
            apiKeyPlaceholder: 'Leave blank to use the default key',
            settingsBackupTitle: 'Backup & Restore',
            backupDescText: 'Save or transfer your chat history via JSON file.',
            exportBtnText: 'Export',
            importBtnText: 'Import',
            importSuccessText: 'Backup restored successfully! App will reload.',
            importErrorText: 'File corrupted or not a MirAI backup! üóø',
            installBtnText: 'Install App',
            invalidImageText: 'Please upload an image file (jpeg, png, webp).',
            betaModelActive: '#3FlashPreviewMode',
            slashCmdSearchTitle: 'Search',
            slashCmdSearchDesc: '/search [search query]',
            slashCmdTranslateTitle: 'Translate',
            slashCmdTranslateDesc: '/translate [text] to [language]',
            slashCmdSummarizeTitle: 'Summarize',
            slashCmdSummarizeDesc: '/summarize [long text]',
            slashCmdRephraseTitle: 'Rephrase',
            slashCmdRephraseDesc: '/rephrase [text] as [tone]',
            slashCmdIdeateTitle: 'Ideate',
            slashCmdIdeateDesc: '/ideate [amount] ideas for [topic]',
            slashCmdFixTitle: 'Fix',
            slashCmdFixDesc: '/fix [text that needs to be corrected]',
            slashCmdExplainTitle: 'Explain',
            slashCmdExplainDesc: '/explain [concept] like I\'m [audience]',
            slashCmdCodeTitle: 'Code',
            slashCmdCodeDesc: '/code a [programming language] function to [description]',
            slashErrorInvalidFormat: 'Error: Invalid format.',
            slashErrorInvalidFormatTranslate: 'Error: Invalid format. Use /translate [text] to [language]',
            slashErrorInvalidFormatRephrase: 'Error: Invalid format. Use /rephrase [text] as [tone]',
            slashErrorInvalidFormatIdeate: 'Error: Invalid format. Use /ideate [number] ideas for [topic]',
            slashErrorInvalidFormatExplain: 'Error: Invalid format. Use /explain [concept] like I\'m [audience]',
            slashErrorInvalidFormatCode: 'Error: Invalid format. Use /code a [language] function to [description]',
            slashErrorInvalidFormatSearch: 'Error: Invalid format. Use /search [query]',
            slashErrorUnknownCommand: 'Error: Unknown command.',
            confirmBtnYes: 'Yes, Delete',
            confirmBtnNo: 'Cancel',
            copyFeedback: 'Text copied to clipboard!',
            pwaInstalledText: 'PWA was installed successfully!',
            apiLimitError: 'Hmm... it seems that this API key has reached its usage limit. If you are still using the default API key, please replace it with your personal API key immediately.',
            settingsSearchTitle: 'Search Configuration',
            searchConfigDesc: 'Configure external search engines for /search command',
            testSearchBtn: 'Test Search',
            clearSearchCacheBtn: 'Clear Cache',
            searchTestResult: 'Search test result for "test": ',
            searchCacheCleared: 'Search cache cleared successfully!',
            searchEngineNotConfigured: 'Search engine not configured',
            searchExample1: '/search artificial intelligence',
            searchExample2: '/search machine learning [engine:wikipedia]',
            searchExample3: '/search OpenAI [type:news] [results:3]',
            searchModeExternal: 'External Search Mode',
            searchModeAI: 'AI Knowledge Base Mode',
            searchModeDescExternal: '/search uses external search engines',
            searchModeDescAI: '/search uses AI training data',
            firstVisitSearchInfo: 'First-time visit: All search engines disabled by default. Enable in Settings if needed.'
        },
        'en-uk': {
            offlineTitle: 'Internet Connection Lost',
            offlineText: 'Please check your WiFi or cellular data connection, then try again.',
            retryButton: 'Retry',
            inputPlaceholder: 'Type your question here...',
            copyFeedback: 'Text copied to clipboard!',
            langSwitchFeedback: 'Language has been changed to',
            errorAPI: 'An error occurred. Please reload the page or try again shortly.\n\nHmm... it appears that this API key has reached its usage limit. If you are still using the default API key, please replace it with your personal API key immediately. Please check the tutorial on the [MirAI GitHub page](https://github.com/Allwaysever/MirAI?tab=readme-ov-file#%EF%B8%8F-setup-using-your-own-api-key).',
            errorFallback: 'Sorry, no answer was found. Please try different keywords.',
            errorConnection: 'Internet connection is unavailable. Please check and try again.',
            checkingConnection: 'Checking internet connection...',
            copySuffix: '\n\n-- Generated by MirAI',
            infoText: 'AI-generated information may be inaccurate. Please verify important facts.',
            settingsHeaderTitle: 'Settings',
            settingsAppearanceTitle: 'Appearance',
            settingsThemeText: 'Select your theme preference:',
            themeLightOption: 'Light',
            themeDarkOption: 'Dark',
            settingsAITitle: 'AI Persona',
            settingsPersonaText: 'Choose the AI\'s response style:',
            personaFormalOption: 'Formal & Professional',
            personaDefaultOption: 'Laid-back & bantering',
            personaCreativeOption: 'Creative & Expressive',
            personaCustomOption: 'Custom Persona',
            customPersonaHint: 'Your prompt will be combined with: "You are MirAI, an AI Assistant, "',
            customPersonaPlaceholder: 'Enter your custom prompt here...',
            settingsMemoryTitle: 'Chat Memory',
            settingsMemoryText: 'Maximum chat bubbles to store:',
            settingsMemoryCurrent: 'Current bubbles: ',
            settingsMemoryMax: 'Max: ',
            settingsMemoryHint: 'Settings will be applied after saving.',
            settingsMemoryWarning: 'Note: Will delete {count} old bubbles when saved.',
            settingsMemorySuccess: 'Memory updated! Keeping {current}/{max} bubbles.',
            settingsAboutTitle: 'About',
            settingsVersionText: `Version: v${VERSION}`,
            settingsAuthorText: 'Developed by Allwaysever',
            githubLink: 'About MirAI',
            licenseLink: 'License',
            helpLink: 'Help Center',
            termsText: 'By using MirAI, you agree to the <a href="T&C/index.html" target="_blank">Terms & Conditions</a>.',
            personaDefaultPrompt: 'You are MirAI, a relaxed and humorous AI assistant. Answer all questions in a friendly style, with a bit of humour, while remaining informative.',
            personaFormalPrompt: 'You are MirAI, a professional AI assistant. Provide well-structured, accurate, and formal responses.',
            personaCreativePrompt: 'You are MirAI, a creative AI assistant. Provide unique, imaginative, and expressive answers to every query.',
            personaCustomPrompt: '',
            placeholderMessages: ['Ask any question.', 'Need help with an idea?', 'Request a translation or summary.', 'How can I assist you?'],
            onlineStatus: 'Connected',
            offlineStatus: 'Disconnected',
            settingsApiTitle: 'Google API Key',
            settingsApiText: 'Enter your custom API Key:',
            apiKeySaved: 'API Key saved successfully.',
            apiKeyRemoved: 'API Key removed. Using default key.',
            dateTimeContextPrompt: '[{dateTime}]:',
            confirmClearMessage: 'Are you sure you want to delete this chat history? This action cannot be undone.',
            confirmClearYes: 'Yes, Delete',
            confirmClearNo: 'Cancel',
            pageTitle: 'MirAI | Your AI Assistant',
            saveApiKeyBtn: 'Save',
            apiKeyPlaceholder: 'Leave blank to use the default key',
            settingsBackupTitle: 'Backup & Restore',
            backupDescText: 'Save or transfer your chat history via JSON file.',
            exportBtnText: 'Export',
            importBtnText: 'Import',
            importSuccessText: 'Backup restored successfully! App will reload.',
            importErrorText: 'File corrupted or not a MirAI backup! üóø',
            installBtnText: 'Install App',
            invalidImageText: 'Please upload an image file (jpeg, png, webp).',
            betaModelActive: '#3FlashPreviewMode',
            slashCmdSearchTitle: 'Search',
            slashCmdSearchDesc: '/search [search query]',
            slashCmdTranslateTitle: 'Translate',
            slashCmdTranslateDesc: '/translate [text] to [language]',
            slashCmdSummarizeTitle: 'Summarize',
            slashCmdSummarizeDesc: '/summarize [long text]',
            slashCmdRephraseTitle: 'Rephrase',
            slashCmdRephraseDesc: '/rephrase [text] as [tone]',
            slashCmdIdeateTitle: 'Ideate',
            slashCmdIdeateDesc: '/ideate [amount] ideas for [topic]',
            slashCmdFixTitle: 'Fix',
            slashCmdFixDesc: '/fix [text that needs to be corrected]',
            slashCmdExplainTitle: 'Explain',
            slashCmdExplainDesc: '/explain [concept] like I\'m [audience]',
            slashCmdCodeTitle: 'Code',
            slashCmdCodeDesc: '/code a [programming language] function to [description]',
            slashErrorInvalidFormat: 'Error: Invalid format.',
            slashErrorInvalidFormatTranslate: 'Error: Invalid format. Use /translate [text] to [language]',
            slashErrorInvalidFormatRephrase: 'Error: Invalid format. Use /rephrase [text] as [tone]',
            slashErrorInvalidFormatIdeate: 'Error: Invalid format. Use /ideate [number] ideas for [topic]',
            slashErrorInvalidFormatExplain: 'Error: Invalid format. Use /explain [concept] like I\'m [audience]',
            slashErrorInvalidFormatCode: 'Error: Invalid format. Use /code a [language] function to [description]',
            slashErrorInvalidFormatSearch: 'Error: Invalid format. Use /search [query]',
            slashErrorUnknownCommand: 'Error: Unknown command.',
            confirmBtnYes: 'Yes, Delete',
            confirmBtnNo: 'Cancel',
            copyFeedback: 'Text copied to clipboard!',
            pwaInstalledText: 'PWA was installed successfully!',
            apiLimitError: 'Hmm... it seems that this API key has reached its usage limit. If you are still using the default API key, please replace it with your personal API key immediately.',
            settingsSearchTitle: 'Search Configuration',
            searchConfigDesc: 'Configure external search engines for /search command',
            testSearchBtn: 'Test Search',
            clearSearchCacheBtn: 'Clear Cache',
            searchTestResult: 'Search test result for "test": ',
            searchCacheCleared: 'Search cache cleared successfully!',
            searchEngineNotConfigured: 'Search engine not configured',
            searchExample1: '/search artificial intelligence',
            searchExample2: '/search machine learning [engine:wikipedia]',
            searchExample3: '/search OpenAI [type:news] [results:3]',
            searchModeExternal: 'External Search Mode',
            searchModeAI: 'AI Knowledge Base Mode',
            searchModeDescExternal: '/search uses external search engines',
            searchModeDescAI: '/search uses AI training data',
            firstVisitSearchInfo: 'First-time visit: All search engines disabled by default. Enable in Settings if needed.'
        },
        'jp': {
            offlineTitle: '„Ç§„É≥„Çø„Éº„Éç„ÉÉ„ÉàÊé•Á∂ö„Åå„ÅÇ„Çä„Åæ„Åõ„Çì',
            offlineText: 'WiFi„Åæ„Åü„ÅØ„Éá„Éº„ÇøÊé•Á∂ö„ÇíÁ¢∫Ë™ç„Åó„ÄÅÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
            retryButton: 'ÂÜçË©¶Ë°å',
            inputPlaceholder: '„Åì„Åì„Å´Ë≥™Âïè„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ...',
            copyFeedback: '„ÉÜ„Ç≠„Çπ„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü„ÄÇ',
            langSwitchFeedback: 'Ë®ÄË™û„ÅåÂ§âÊõ¥„Åï„Çå„Åæ„Åó„Åü',
            errorAPI: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åô„Çã„Åã„ÄÅ„Åó„Å∞„Çâ„Åè„Åó„Å¶„Åã„Çâ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ\n\nHmm... „Åì„ÅÆAPI„Ç≠„Éº„ÅØ‰ΩøÁî®Âà∂Èôê„Å´ÈÅî„Åó„Åü„Çà„ÅÜ„Åß„Åô„ÄÇ„Éá„Éï„Ç©„É´„Éà„ÅÆAPI„Ç≠„Éº„Çí„Åæ„Å†‰ΩøÁî®„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åô„Åê„Å´ÂÄã‰∫∫Áî®„ÅÆAPI„Ç≠„Éº„Å´Â§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË©≥Á¥∞„Å™ÊâãÈ†Ü„ÅØ[MirAI„ÅÆGitHub„Éö„Éº„Ç∏](https://github.com/Allwaysever/MirAI?tab=readme-ov-file#%EF%B8%8F-setup-using-your-own-api-key)„ÅÆ„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ',
            errorFallback: 'Áî≥„ÅóË®≥„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÅÂõûÁ≠î„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÂà•„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„Åß„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
            errorConnection: '„Ç§„É≥„Çø„Éº„Éç„ÉÉ„Éà„Å´Êé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÊé•Á∂ö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            checkingConnection: '„Ç§„É≥„Çø„Éº„Éç„ÉÉ„ÉàÊé•Á∂ö„ÇíÁ¢∫Ë™ç‰∏≠...',
            copySuffix: '\n\n-- MirAI„Å´„Çà„Å£„Å¶ÁîüÊàê',
            infoText: 'AI„ÅåÁîüÊàê„Åó„ÅüÊÉÖÂ†±„ÅØ‰∏çÊ≠£Á¢∫„Å™Â†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÈáçË¶Å„Å™‰∫ãÂÆü„ÅØÂÜçÂ∫¶„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ',
            settingsHeaderTitle: 'Ë®≠ÂÆö',
            settingsAppearanceTitle: 'Â§ñË¶≥',
            settingsThemeText: '„ÉÜ„Éº„Éû„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:',
            themeLightOption: '„É©„Ç§„Éà',
            themeDarkOption: '„ÉÄ„Éº„ÇØ',
            settingsAITitle: 'AI„ÅÆ„Éö„É´„ÇΩ„Éä',
            settingsPersonaText: 'AI„ÅÆÂøúÁ≠î„Çπ„Çø„Ç§„É´„ÇíÈÅ∏Êäû:',
            personaFormalOption: '„Éï„Ç©„Éº„Éû„É´„Éª„Éó„É≠',
            personaDefaultOption: '„ÅÆ„Çì„Å≥„Çä„Åó„Å¶„Å¶ÂÜóË´áÂ•Ω„Åç',
            personaCreativeOption: '„ÇØ„É™„Ç®„Ç§„ÉÜ„Ç£„Éñ„ÉªË°®ÁèæË±ä„Åã',
            personaCustomOption: '„Ç´„Çπ„Çø„É†„Éö„É´„ÇΩ„Éä',
            customPersonaHint: '„Éó„É≠„É≥„Éó„Éà„ÅØ„Äå„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅAI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÅ„Äç„Å®ÁµêÂêà„Åï„Çå„Åæ„Åô',
            customPersonaPlaceholder: '„Ç´„Çπ„Çø„É†„Éó„É≠„É≥„Éó„Éà„Çí„Åì„Åì„Å´ÂÖ•Âäõ...',
            settingsMemoryTitle: '„ÉÅ„É£„ÉÉ„Éà„É°„É¢„É™',
            settingsMemoryText: '‰øùÂ≠ò„Åô„ÇãÊúÄÂ§ß„ÉÅ„É£„ÉÉ„Éà„Éê„Éñ„É´Êï∞:',
            settingsMemoryCurrent: 'ÁèæÂú®„ÅÆ„Éê„Éñ„É´: ',
            settingsMemoryMax: 'ÊúÄÂ§ß: ',
            settingsMemoryHint: 'Ë®≠ÂÆö„ÅØ‰øùÂ≠òÂæå„Å´ÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇ',
            settingsMemoryWarning: 'Ê≥®ÊÑè: ‰øùÂ≠òÊôÇ„Å´{count}ÂÄã„ÅÆÂè§„ÅÑ„Éê„Éñ„É´„ÇíÂâäÈô§„Åó„Åæ„Åô„ÄÇ',
            settingsMemorySuccess: '„É°„É¢„É™„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„ÅüÔºÅ{current}/{max}ÂÄã„ÅÆ„Éê„Éñ„É´„Çí‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ',
            settingsAboutTitle: '„Ç¢„Éó„É™„Å´„Å§„ÅÑ„Å¶',
            settingsVersionText: `„Éê„Éº„Ç∏„Éß„É≥: v${VERSION}`,
            settingsAuthorText: 'ÈñãÁô∫ËÄÖ: Allwaysever',
            githubLink: 'MirAI„Å´„Å§„ÅÑ„Å¶',
            licenseLink: '„É©„Ç§„Çª„É≥„Çπ',
            helpLink: '„Éò„É´„Éó„Çª„É≥„Çø„Éº',
            termsText: 'MirAI„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„Å´„Çà„Çä„ÄÅ<a href="T&C/index.html" target="_blank">Âà©Áî®Ë¶èÁ¥Ñ</a>„Å´ÂêåÊÑè„Åó„Åü„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ',
            personaDefaultPrompt: '„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅ„É™„É©„ÉÉ„ÇØ„Çπ„Åó„Å¶ÂÜóË´áÂ•Ω„Åç„Å™AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ„Éï„É¨„É≥„Éâ„É™„Éº„Å™„Çπ„Çø„Ç§„É´„Åß„ÄÅÂ∞ë„Åó„É¶„Éº„É¢„Ç¢„Çí‰∫§„Åà„Å™„Åå„Çâ„ÇÇ„ÄÅÊÉÖÂ†±„ÇíÊèê‰æõ„Åô„Çã„Çà„ÅÜ„Å´„Åô„Åπ„Å¶„ÅÆË≥™Âïè„Å´Á≠î„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            personaFormalPrompt: '„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅ„Éó„É≠„Éï„Çß„ÉÉ„Ç∑„Éß„Éä„É´„Å™AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇÊßãÈÄ†Âåñ„Åï„Çå„ÄÅÊ≠£Á¢∫„Åß„ÄÅ„Éï„Ç©„Éº„Éû„É´„Å™Ë®ÄËëâÈÅ£„ÅÑ„ÅßÂõûÁ≠î„ÇíÊèê‰æõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            personaCreativePrompt: '„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅÂâµÈÄ†ÁöÑ„Å™AI„Ç¢„Ç∑„Çπ„ÇøNT„Åß„Åô„ÄÇ„Åô„Åπ„Å¶„ÅÆË≥™Âïè„Å´ÂØæ„Åó„Å¶„ÄÅ„É¶„Éã„Éº„ÇØ„ÅßÊÉ≥ÂÉèÂäõ„Å´ÂØå„Çì„Å†Ë°®ÁèæÂäõË±ä„Åã„Å™ÂõûÁ≠î„Çí„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            personaCustomPrompt: '',
            placeholderMessages: ['Ë≥™Âïè„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', '„Ç¢„Ç§„Éá„Ç¢„ÅåÂøÖË¶Å„Åß„Åô„ÅãÔºü', 'ÁøªË®≥„Åæ„Åü„ÅØË¶ÅÁ¥Ñ„Çí‰æùÈ†º„ÄÇ', '‰Ωï„Åã„ÅäÊâã‰ºù„ÅÑ„Åß„Åç„Çã„Åì„Å®„ÅØ„ÅÇ„Çä„Åæ„Åô„ÅãÔºü'],
            onlineStatus: 'Êé•Á∂öÊ∏à„Åø',
            offlineStatus: 'ÂàáÊñ≠',
            settingsApiTitle: 'Google API„Ç≠„Éº',
            settingsApiText: '„Ç´„Çπ„Çø„É†API„Ç≠„Éº„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:',
            apiKeySaved: 'API„Ç≠„Éº„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åó„Åü„ÄÇ',
            apiKeyRemoved: 'API„Ç≠„Éº„ÅåÂâäÈô§„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Éá„Éï„Ç©„É´„Éà„Ç≠„Éº„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ',
            dateTimeContextPrompt: '[{dateTime}]:',
            confirmClearMessage: '„Åì„ÅÆ„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„ÇíÂâäÈô§„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ',
            confirmClearYes: '„ÅØ„ÅÑ„ÄÅÂâäÈô§„Åó„Åæ„Åô',
            confirmClearNo: '„Ç≠„É£„É≥„Çª„É´',
            pageTitle: 'MirAI | AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà',
            saveApiKeyBtn: '‰øùÂ≠ò',
            apiKeyPlaceholder: '„Éá„Éï„Ç©„É´„Éà„Ç≠„Éº„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÅØÁ©∫Ê¨Ñ',
            settingsBackupTitle: '„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Å®Âæ©ÂÖÉ',
            backupDescText: 'JSON„Éï„Ç°„Ç§„É´„Åß„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„Çí‰øùÂ≠ò„Åæ„Åü„ÅØËª¢ÈÄÅ„Åó„Åæ„Åô„ÄÇ',
            exportBtnText: '„Ç®„ÇØ„Çπ„Éù„Éº„Éà',
            importBtnText: '„Ç§„É≥„Éù„Éº„Éà',
            importSuccessText: '„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÅåÊ≠£Â∏∏„Å´Âæ©ÂÖÉ„Åï„Çå„Åæ„Åó„ÅüÔºÅ„Ç¢„Éó„É™„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Åæ„Åô„ÄÇ',
            importErrorText: '„Éï„Ç°„Ç§„É´„ÅåÂ£ä„Çå„Å¶„ÅÑ„Çã„Åã„ÄÅMirAI„ÅÆ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÂΩ¢Âºè„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„ÇìÔºÅüóø',
            installBtnText: '„Ç¢„Éó„É™„Çí„Ç§„É≥„Çπ„Éà„Éº„É´',
            invalidImageText: 'ÁîªÂÉè„Éï„Ç°„Ç§„É´ÔºàJPEG„ÄÅPNG„ÄÅWebPÔºâ„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            betaModelActive: '#3Flash„Éó„É¨„Éì„É•„Éº„É¢„Éº„Éâ',
            slashCmdSearchTitle: 'Ê§úÁ¥¢',
            slashCmdSearchDesc: '/search [Ê§úÁ¥¢„ÇØ„Ç®„É™]',
            slashCmdTranslateTitle: 'ÁøªË®≥',
            slashCmdTranslateDesc: '/translate [„ÉÜ„Ç≠„Çπ„Éà] to [Ë®ÄË™û]',
            slashCmdSummarizeTitle: 'Ë¶ÅÁ¥Ñ',
            slashCmdSummarizeDesc: '/summarize [Èï∑„ÅÑ„ÉÜ„Ç≠„Çπ„Éà]',
            slashCmdRephraseTitle: 'Ë®Ä„ÅÑÊèõ„Åà',
            slashCmdRephraseDesc: '/rephrase [„ÉÜ„Ç≠„Çπ„Éà] as [Âè£Ë™ø]',
            slashCmdIdeateTitle: '„Ç¢„Ç§„Éá„Ç¢ÁîüÊàê',
            slashCmdIdeateDesc: '/ideate [Êï∞] ideas for [„Éà„Éî„ÉÉ„ÇØ]',
            slashCmdFixTitle: '‰øÆÊ≠£',
            slashCmdFixDesc: '/fix [‰øÆÊ≠£„ÅåÂøÖË¶Å„Å™„ÉÜ„Ç≠„Çπ„Éà]',
            slashCmdExplainTitle: 'Ë™¨Êòé',
            slashCmdExplainDesc: '/explain [Ê¶ÇÂøµ] like I\'m [ÂØæË±°]',
            slashCmdCodeTitle: '„Ç≥„Éº„Éâ',
            slashCmdCodeDesc: '/code a [„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û] function to [Ë™¨Êòé]',
            slashErrorInvalidFormat: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ',
            slashErrorInvalidFormatTranslate: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /translate [„ÉÜ„Ç≠„Çπ„Éà] to [Ë®ÄË™û] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatRephrase: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /rephrase [„ÉÜ„Ç≠„Çπ„Éà] as [Âè£Ë™ø] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatIdeate: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /ideate [Êï∞] ideas for [„Éà„Éî„ÉÉ„ÇØ] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatExplain: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /explain [Ê¶ÇÂøµ] like I\'m [ÂØæË±°] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatCode: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /code a [Ë®ÄË™û] function to [Ë™¨Êòé] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatSearch: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /search [„ÇØ„Ç®„É™] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorUnknownCommand: '„Ç®„É©„Éº: ‰∏çÊòé„Å™„Ç≥„Éû„É≥„Éâ„Åß„Åô„ÄÇ',
            confirmBtnYes: '„ÅØ„ÅÑ„ÄÅÂâäÈô§„Åó„Åæ„Åô',
            confirmBtnNo: '„Ç≠„É£„É≥„Çª„É´',
            copyFeedback: '„ÉÜ„Ç≠„Çπ„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü„ÄÇ',
            pwaInstalledText: 'PWA„ÅåÊ≠£Â∏∏„Å´„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Åæ„Åó„ÅüÔºÅ',
            apiLimitError: '„Åì„ÅÆAPI„Ç≠„Éº„ÅØ‰ΩøÁî®Âà∂Èôê„Å´ÈÅî„Åó„Åü„Çà„ÅÜ„Åß„Åô„ÄÇ„Éá„Éï„Ç©„É´„Éà„ÅÆAPI„Ç≠„Éº„Çí„Åæ„Å†‰ΩøÁî®„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åô„Åê„Å´ÂÄã‰∫∫Áî®„ÅÆAPI„Ç≠„Éº„Å´Â§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            settingsSearchTitle: 'Ê§úÁ¥¢Ë®≠ÂÆö',
            searchConfigDesc: '/search„Ç≥„Éû„É≥„Éâ„ÅÆÂ§ñÈÉ®Ê§úÁ¥¢„Ç®„É≥„Ç∏„É≥„ÇíË®≠ÂÆö',
            testSearchBtn: 'Ê§úÁ¥¢„ÉÜ„Çπ„Éà',
            clearSearchCacheBtn: '„Ç≠„É£„ÉÉ„Ç∑„É•ÂâäÈô§',
            searchTestResult: '"test"„ÅÆÊ§úÁ¥¢„ÉÜ„Çπ„ÉàÁµêÊûú: ',
            searchCacheCleared: 'Ê§úÁ¥¢„Ç≠„É£„ÉÉ„Ç∑„É•„ÅåÊ≠£Â∏∏„Å´ÂâäÈô§„Åï„Çå„Åæ„Åó„ÅüÔºÅ',
            searchEngineNotConfigured: 'Ê§úÁ¥¢„Ç®„É≥„Ç∏„É≥„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì',
            searchExample1: '/search artificial intelligence',
            searchExample2: '/search machine learning [engine:wikipedia]',
            searchExample3: '/search OpenAI [type:news] [results:3]',
            searchModeExternal: 'Â§ñÈÉ®Ê§úÁ¥¢„É¢„Éº„Éâ',
            searchModeAI: 'AIÁü•Ë≠ò„Éô„Éº„Çπ„É¢„Éº„Éâ',
            searchModeDescExternal: '/search„ÅØÂ§ñÈÉ®Ê§úÁ¥¢„Ç®„É≥„Ç∏„É≥„Çí‰ΩøÁî®',
            searchModeDescAI: '/search„ÅØAI„Éà„É¨„Éº„Éã„É≥„Ç∞„Éá„Éº„Çø„Çí‰ΩøÁî®',
            firstVisitSearchInfo: 'ÂàùÂõûË®™ÂïèÔºö„Åô„Åπ„Å¶„ÅÆÊ§úÁ¥¢„Ç®„É≥„Ç∏„É≥„ÅØ„Éá„Éï„Ç©„É´„Éà„ÅßÁÑ°Âäπ„Åß„Åô„ÄÇÂøÖË¶Å„Å´Âøú„Åò„Å¶Ë®≠ÂÆö„ÅßÊúâÂäπ„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
        }
    };

    // === ENHANCED AI LOADING FUNCTIONS ===
    function showLoading() { 
        const startTime = Date.now();
        
        const loadingContainer = document.createElement('div'); 
        loadingContainer.classList.add('ai-loading-container', 'fade-in');
        
        // Stopwatch
        const stopwatch = document.createElement('div');
        stopwatch.classList.add('ai-stopwatch');
        stopwatch.textContent = '00.000s';
        loadingContainer.appendChild(stopwatch);
        
        // Progress bar container
        const progressContainer = document.createElement('div');
        progressContainer.classList.add('ai-progress-container');
        
        const progressBar = document.createElement('div');
        progressBar.classList.add('ai-progress-bar');
        progressContainer.appendChild(progressBar);
        loadingContainer.appendChild(progressContainer);
        
        // Generating text
        const generatingText = document.createElement('div');
        generatingText.classList.add('ai-generating-text');
        generatingText.textContent = 'Generating response...';
        loadingContainer.appendChild(generatingText);
        
        // Processing time (will be shown after completion)
        const processingTime = document.createElement('div');
        processingTime.classList.add('ai-processing-time');
        loadingContainer.appendChild(processingTime);
        
        // Update stopwatch every 10ms
        const stopwatchInterval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            const seconds = (elapsed / 1000).toFixed(3);
            stopwatch.textContent = `${seconds}s`;
        }, 10);
        
        // Store data for cleanup
        loadingContainer.dataset.startTime = startTime;
        loadingContainer.dataset.stopwatchInterval = stopwatchInterval;
        
        elements.chatMessages.appendChild(loadingContainer);
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
        
        return loadingContainer; 
    }

    function completeLoading(loadingElement, success = true, message = null) {
        const stopwatch = loadingElement.querySelector('.ai-stopwatch');
        const progressBar = loadingElement.querySelector('.ai-progress-bar');
        const processingTime = loadingElement.querySelector('.ai-processing-time');
        const startTime = parseInt(loadingElement.dataset.startTime);
        
        // Clear interval
        if (loadingElement.dataset.stopwatchInterval) {
            clearInterval(parseInt(loadingElement.dataset.stopwatchInterval));
        }
        
        // Calculate total time
        const totalTime = (Date.now() - startTime) / 1000;
        
        // Mark progress as complete
        if (progressBar) {
            progressBar.classList.add('complete');
        }
        
        // Update stopwatch with final time
        if (stopwatch) {
            stopwatch.textContent = `${totalTime.toFixed(3)}s`;
            stopwatch.style.color = success ? 'var(--srui-success)' : 'var(--srui-error)';
        }
        
        // Show processing time
        if (processingTime) {
            if (message) {
                processingTime.textContent = message;
            } else {
                processingTime.textContent = `Processed in ${totalTime.toFixed(3)} seconds`;
            }
            processingTime.style.opacity = '1';
        }
        
        // Remove generating text
        const generatingText = loadingElement.querySelector('.ai-generating-text');
        if (generatingText) {
            generatingText.style.opacity = '0';
            setTimeout(() => {
                if (generatingText.parentNode) {
                    generatingText.remove();
                }
            }, 300);
        }
        
        // Return total time for use in typewriter effect
        return totalTime;
    }

    let slashCommands = [];
    let chatHistory = [];
    let abortController = null;
    let currentLanguage = 'en';
    let currentPersona = 'default';
    let currentImageData = null;
    let elements;
    let tempMaxBubbles = 50; // Temporary state for memory slider

    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const formattedDate = `${year}-${month}-${day}_${hours}-${minutes}`;
    console.log(formattedDate);

    // === CHAT MEMORY MANAGEMENT FUNCTIONS ===
    function updateMemorySliderUI(value) {
        const sliderValue = document.getElementById('maxBubbleValue');
        const currentBubbleCount = document.getElementById('currentBubbleCount');
        const memoryStatusMessage = document.getElementById('memoryStatusMessage');
        
        if (sliderValue) sliderValue.textContent = value;
        
        // ‚≠ê‚≠ê FIXED: Calculate total chat bubbles (excluding persona prompt at index 0)
        const totalBubbles = chatHistory.length > 0 ? chatHistory.length - 1 : 0;
        
        if (currentBubbleCount) {
            const lang = uiStrings[currentLanguage];
            // Show both the actual count and the limit
            currentBubbleCount.textContent = lang.settingsMemoryCurrent + totalBubbles;
        }
        
        // Show warning if current count exceeds new limit
        if (memoryStatusMessage && totalBubbles > parseInt(value)) {
            const lang = uiStrings[currentLanguage];
            const excess = totalBubbles - parseInt(value);
            memoryStatusMessage.textContent = lang.settingsMemoryWarning.replace('{count}', excess);
            memoryStatusMessage.className = 'status-message warning';
        } else if (memoryStatusMessage) {
            const lang = uiStrings[currentLanguage];
            memoryStatusMessage.textContent = lang.settingsMemoryHint;
            memoryStatusMessage.className = 'status-message';
        }
        
        // Store temporary value
        tempMaxBubbles = parseInt(value);
    }

    function applyMemoryLimit(newLimit) {
        console.log(`üéØ Manually applying new memory limit: ${newLimit}`);
        
        const maxHistoryLength = parseInt(newLimit);
        const lang = uiStrings[currentLanguage];
        
        if (chatHistory.length > maxHistoryLength + 1) { // +1 for persona prompt
            // Keep persona prompt at index 0
            const personaPrompt = chatHistory[0];
            
            // Calculate how many messages to keep (excluding persona prompt)
            const messagesToKeep = maxHistoryLength;
            
            // Get the most recent messages (excluding persona prompt)
            const recentMessages = chatHistory.slice(-messagesToKeep);
            
            // Reconstruct history with persona prompt + recent messages
            chatHistory = [personaPrompt, ...recentMessages];
            
            // Save to localStorage
            localStorage.setItem('miraiChatHistory', JSON.stringify(chatHistory));
            
            // Update UI
            renderChatMessages();
            
            // Show success message
            showCopyFeedback(lang.settingsMemorySuccess
                .replace('{current}', recentMessages.length)
                .replace('{max}', maxHistoryLength));
        } else {
            // No trimming needed, just update the limit
            console.log(`‚ÑπÔ∏è No trimming needed (${chatHistory.length - 1}/${maxHistoryLength} bubbles)`);
        }
        
        // Save limit to localStorage
        localStorage.setItem('miraiMaxBubbles', newLimit.toString());
        
        // Update slider display
        updateMemorySliderUI(newLimit);
    }

    function renderChatMessages() {
        elements.chatMessages.innerHTML = '';
        
        // Skip persona prompt (index 0)
        for (let i = 1; i < chatHistory.length; i++) {
            const message = chatHistory[i];
            
            if (message.role === "user") {
                const userBubble = document.createElement('div');
                userBubble.classList.add('chat-bubble', 'user-bubble', 'fade-in');
                
                let displayText = '';
                let hasImage = false;
                
                message.parts.forEach(part => {
                    if (part.text) {
                        // Extract just the user message (remove context prompt)
                        const text = part.text;
                        const contextMatch = text.match(/\[{dateTime}\]:\n\n"([\s\S]*)"$/);
                        if (contextMatch) {
                            displayText = contextMatch[1];
                        } else {
                            displayText = text;
                        }
                    } else if (part.inlineData) {
                        hasImage = true;
                    }
                });
                
                if (hasImage) {
                    userBubble.innerHTML = `<div style="margin-bottom: 8px;"><i class="fas fa-image"></i> Gambar terlampir</div>`;
                    const textNode = document.createTextNode(displayText);
                    userBubble.appendChild(textNode);
                } else {
                    userBubble.textContent = displayText;
                }
                
                elements.chatMessages.appendChild(userBubble);
                
            } else if (message.role === "model") {
                const aiBubble = createAiBubble(message.parts[0].text, true);
                elements.chatMessages.appendChild(aiBubble);
            }
        }
        
        // Update toggleChatUI based on whether we have messages
        if (chatHistory.length > 1) {
            toggleChatUI(true);
        } else {
            toggleChatUI(false);
        }
        
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
    }

    // --- LOGIKA UTAMA MIRAI ENCRYPTED DATA FILE (.medf) ---
    const MIRAI_CONFIG = {
        saltLength: 16,
        ivLength: 12,
        iterations: 100000,
        HEADER_TEXT: "{MirAI Encrypted Data Files v1.0 By Allwaysever}"
    };

    async function processExportMEDF(dataJSON, password) {
        const signatureData = {
            _signature: {
                headerText: MIRAI_CONFIG.HEADER_TEXT,
                headerCode: generateHeaderCode(MIRAI_CONFIG.HEADER_TEXT),
                timestamp: new Date().toISOString(),
                version: "1.0"
            },
            ...dataJSON
        };
        
        console.log('üîê Adding authenticity signature for export');
        
        const encoder = new TextEncoder();
        const salt = window.crypto.getRandomValues(new Uint8Array(MIRAI_CONFIG.saltLength));
        const iv = window.crypto.getRandomValues(new Uint8Array(MIRAI_CONFIG.ivLength));

        const passwordKey = await window.crypto.subtle.importKey(
            "raw", encoder.encode(password), "PBKDF2", false, ["deriveKey"]
        );
        const key = await window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt: salt, iterations: MIRAI_CONFIG.iterations, hash: "SHA-256" },
            passwordKey, { name: "AES-GCM", length: 256 }, false, ["encrypt"]
        );

        const encrypted = await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv }, key, encoder.encode(JSON.stringify(signatureData))
        );

        const finalBlob = new Blob([salt, iv, new Uint8Array(encrypted)], {type: "application/octet-stream"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(finalBlob);
        a.download = `MirAIBackup_ENCRYPTED_${formattedDate}.medf`;
        a.click();
    }

    function generateHeaderCode(text) {
        let code = '';
        for (let i = 0; i < text.length; i++) {
            const charCode = text.charCodeAt(i);
            const transformedCode = (charCode + 2) * 3;
            code += transformedCode.toString().padStart(4, '0');
        }
        return code;
    }

    async function processImportMEDF(file, password) {
      try {
        const buffer = await file.arrayBuffer();
        const uint8View = new Uint8Array(buffer);
        
        const salt = uint8View.slice(0, 16);
        const iv = uint8View.slice(16, 28);
        const encryptedData = uint8View.slice(28);
        
        console.log('MEDF Import Debug:', {
          totalSize: buffer.byteLength,
          saltSize: salt.length,
          ivSize: iv.length,
          dataSize: encryptedData.length
        });
        
        const encoder = new TextEncoder();
        
        const passwordKey = await window.crypto.subtle.importKey(
          "raw", 
          encoder.encode(password), 
          "PBKDF2", 
          false, 
          ["deriveKey"]
        );
        
        const key = await window.crypto.subtle.deriveKey(
          { 
            name: "PBKDF2", 
            salt: salt, 
            iterations: MIRAI_CONFIG.iterations, 
            hash: "SHA-256" 
          },
          passwordKey, 
          { name: "AES-GCM", length: 256 }, 
          false, 
          ["decrypt"]
        );
        
        const decrypted = await window.crypto.subtle.decrypt(
          { name: "AES-GCM", iv: iv }, 
          key, 
          encryptedData
        );
        
        const decryptedText = new TextDecoder().decode(decrypted);
        const data = JSON.parse(decryptedText);
        
        console.log('üîç Validating backup authenticity...');
        
        if (!data._signature) {
          console.warn('‚ö†Ô∏è Backup file does not have signature');
          alert('‚ö†Ô∏è Warning: Backup file does not have authenticity signature.\nFile may not be from official MirAI.');
        } else {
          const HEADER_TEXT = MIRAI_CONFIG.HEADER_TEXT;
          
          if (data._signature.headerText !== HEADER_TEXT) {
            throw new Error("‚ùå Backup file tidak otentik! Header text tidak sesuai.");
          }
          
          let expectedCode = '';
          for (let i = 0; i < HEADER_TEXT.length; i++) {
            const charCode = HEADER_TEXT.charCodeAt(i);
            const transformedCode = (charCode + 2) * 3;
            expectedCode += transformedCode.toString().padStart(4, '0');
          }
          
          if (data._signature.headerCode !== expectedCode) {
            throw new Error("‚ùå Backup file is not authentic! Header code does not match.");
          }
          
          console.log('‚úÖ Backup file verified as authentic');
        }
        
        return data;
        
      } catch (e) {
        console.error('MEDF Import Error:', e);
        
        if (e.message.includes('tidak otentik')) {
          throw new Error("‚ùå The backup file is not authentic or has been modified!\n\n" +
                         "Files may be:\n" +
                         "‚Ä¢ Not an official backup of MirAI\n" +
                         "‚Ä¢ Has been modified by another party\n" +
                         "‚Ä¢ Experiencing data corruption\n\n" +
                         "Use the original backup file from MirAI.");
        } else {
          throw new Error("Wrong password or corrupted .medf file!");
        }
      }
    }

    // === ADVANCED SEARCH FUNCTIONS ===
    async function performExternalSearch(query, engine = 'searchapi', count = 5, type = 'web') {
        try {
            const cacheKey = `${engine}:${query}:${count}:${type}`;
            const cached = searchCache.get(cacheKey);
            
            if (cached && (Date.now() - cached.timestamp) < SEARCH_CONFIG.cacheDuration) {
                console.log('Using cached search results');
                return cached.result;
            }
            
            console.log(`üîç Searching ${engine} for: ${query}`);
            
            let searchResult;
            
            switch(engine.toLowerCase()) {
                case 'searchapi':
                    searchResult = await searchWithSearchAPI(query, count, type);
                    break;
                case 'google':
                    searchResult = await searchGoogle(query, count, type);
                    break;
                case 'duckduckgo':
                    searchResult = await searchDuckDuckGo(query, count);
                    break;
                case 'wikipedia':
                    searchResult = await searchWikipedia(query, count);
                    break;
                default:
                    searchResult = `Search engine "${engine}" not supported. Available: searchapi, google, duckduckgo, wikipedia`;
            }
            
            if (searchResult && !searchResult.startsWith('Error:')) {
                searchCache.set(cacheKey, {
                    result: searchResult,
                    timestamp: Date.now()
                });
                
                if (searchCache.size > 50) {
                    const firstKey = searchCache.keys().next().value;
                    searchCache.delete(firstKey);
                }
            }
            
            return searchResult;
            
        } catch (error) {
            console.error('Search error:', error);
            return `Error performing search: ${error.message}`;
        }
    }

    async function searchWithSearchAPI(query, count = 5, type = 'web') {
        const config = SEARCH_CONFIG.engines.searchapi;
        
        if (!config.apiKey) {
            return "‚ö†Ô∏è SearchAPI.io not configured. Please add your API Key.\n\n" +
                   "Get it from: https://www.searchapi.io\n" +
                   "Free tier available with 100 searches/month";
        }
        
        if (!config.enabled) {
            return "SearchAPI.io is disabled in settings.";
        }
        
        const params = new URLSearchParams({
            api_key: config.apiKey,
            q: query,
            engine: config.engine || 'google',
            num: Math.min(count, 10)
        });
        
        if (type === 'news') {
            params.set('engine', 'google_news');
        } else if (type === 'images') {
            params.set('engine', 'google_images');
        }
        
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), SEARCH_CONFIG.timeout);
            
            const response = await fetch(`${config.endpoint}?${params}`, {
                signal: controller.signal,
                headers: {
                    'Accept': 'application/json'
                }
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`SearchAPI.io error: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (!data.organic_results || data.organic_results.length === 0) {
                return `No results found for "${query}"`;
            }
            
            let formattedResults = `üîç **Search Results for: "${query}"**\n\n`;
            formattedResults += `*Engine: SearchAPI.io (${type})*\n\n`;
            
            data.organic_results.slice(0, count).forEach((item, index) => {
                formattedResults += `${index + 1}. **[${item.title}](${item.link})**\n`;
                formattedResults += `   ${item.snippet || item.description || 'No description available'}\n`;
                
                if (item.thumbnail) {
                    formattedResults += `   ![Preview](${item.thumbnail})\n`;
                }
                
                formattedResults += '\n';
            });
            
            if (data.answer_box && data.answer_box.answer) {
                formattedResults = `üí° **Quick Answer:** ${data.answer_box.answer}\n\n` + formattedResults;
            }
            
            formattedResults += `\n---\n`;
            formattedResults += `*Try: /search "${query}" [engine:google] [results:3]*`;
            
            return formattedResults;
            
        } catch (error) {
            if (error.name === 'AbortError') {
                return `Search timeout. Please try again with a simpler query.`;
            }
            return `Error searching with SearchAPI.io: ${error.message}`;
        }
    }

    async function searchGoogle(query, count = 5, type = 'web') {
        const config = SEARCH_CONFIG.engines.google;
        
        if (!config.apiKey || !config.cx) {
            return "‚ö†Ô∏è Google Search API not configured. Please add your API Key and Search Engine ID.\n\n" +
                   "Get them from: https://console.cloud.google.com/apis/credentials\n" +
                   "Create CSE at: https://programmablesearchengine.google.com/";
        }
        
        if (!config.enabled) {
            return "Google Search is disabled in settings.";
        }
        
        const params = new URLSearchParams({
            key: config.apiKey,
            cx: config.cx,
            q: query,
            num: Math.min(count, 10),
            safe: 'active'
        });
        
        if (type === 'news') {
            params.append('dateRestrict', 'm1');
            params.append('sort', 'date');
        } else if (type === 'images') {
            params.append('searchType', 'image');
        }
        
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), SEARCH_CONFIG.timeout);
            
            const response = await fetch(`${config.endpoint}?${params}`, {
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`Google API error: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (!data.items || data.items.length === 0) {
                return `No results found for "${query}"`;
            }
            
            let formattedResults = `üîç **Search Results for: "${query}"**\n\n`;
            formattedResults += `*Engine: Google (${type})*\n\n`;
            
            data.items.slice(0, count).forEach((item, index) => {
                formattedResults += `${index + 1}. **[${item.title}](${item.link})**\n`;
                formattedResults += `   ${item.snippet || 'No description available'}\n`;
                
                if (item.pagemap?.metatags?.[0]?.['og:image']) {
                    formattedResults += `   ![Preview](${item.pagemap.metatags[0]['og:image']})\n`;
                }
                
                formattedResults += '\n';
            });
            
            formattedResults += `\n---\n`;
            formattedResults += `*Try: /search "${query}" [engine:duckduckgo] [results:3]*`;
            
            return formattedResults;
            
        } catch (error) {
            if (error.name === 'AbortError') {
                return `Search timeout. Please try again with a simpler query.`;
            }
            return `Error searching Google: ${error.message}`;
        }
    }

    async function searchDuckDuckGo(query, count = 5) {
        const config = SEARCH_CONFIG.engines.duckduckgo;
        
        if (!config.enabled) {
            return "DuckDuckGo Search is disabled in settings.";
        }
        
        const params = new URLSearchParams({
            q: query,
            format: config.format,
            no_html: '1',
            skip_disambig: '1'
        });
        
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), SEARCH_CONFIG.timeout);
            
            const response = await fetch(`${config.endpoint}?${params}`, {
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            const data = await response.json();
            
            if (!data.AbstractText && (!data.RelatedTopics || data.RelatedTopics.length === 0)) {
                return `No results found for "${query}"`;
            }
            
            let formattedResults = `üîç **Search Results for: "${query}"**\n\n`;
            formattedResults += `*Engine: DuckDuckGo*\n\n`;
            
            if (data.AbstractText) {
                formattedResults += `**Instant Answer:**\n${data.AbstractText}\n\n`;
                if (data.AbstractURL) {
                    formattedResults += `Source: [${data.AbstractSource}](${data.AbstractURL})\n\n`;
                }
            }
            
            if (data.RelatedTopics && data.RelatedTopics.length > 0) {
                formattedResults += `**Related Results:**\n`;
                
                const results = data.RelatedTopics.slice(0, count).filter(item => item.Text);
                
                results.forEach((item, index) => {
                    formattedResults += `${index + 1}. ${item.Text}\n`;
                    if (item.FirstURL) {
                        formattedResults += `   [Link](${item.FirstURL})\n`;
                    }
                    formattedResults += '\n';
                });
            }
            
            return formattedResults;
            
        } catch (error) {
            if (error.name === 'AbortError') {
                return `Search timeout. Please try again.`;
            }
            return `Error searching DuckDuckGo: ${error.message}`;
        }
    }

    async function searchWikipedia(query, count = 5) {
        const config = SEARCH_CONFIG.engines.wikipedia;
        
        if (!config.enabled) {
            return "Wikipedia Search is disabled in settings.";
        }
        
        const params = new URLSearchParams({
            action: 'query',
            list: 'search',
            srsearch: query,
            format: 'json',
            origin: '*',
            srlimit: count
        });
        
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), SEARCH_CONFIG.timeout);
            
            const response = await fetch(`${config.endpoint}?${params}`, {
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            const data = await response.json();
            
            if (!data.query?.search || data.query.search.length === 0) {
                return `No Wikipedia articles found for "${query}"`;
            }
            
            let formattedResults = `üìö **Wikipedia Results for: "${query}"**\n\n`;
            
            data.query.search.forEach((item, index) => {
                const pageId = item.pageid;
                const url = `https://en.wikipedia.org/?curid=${pageId}`;
                
                formattedResults += `${index + 1}. **[${item.title}](${url})**\n`;
                formattedResults += `   ${item.snippet.replace(/<[^>]*>/g, '')}...\n\n`;
            });
            
            formattedResults += `[üîó View all results](https://en.wikipedia.org/w/index.php?search=${encodeURIComponent(query)})`;
            
            return formattedResults;
            
        } catch (error) {
            if (error.name === 'AbortError') {
                return `Search timeout. Please try again.`;
            }
            return `Error searching Wikipedia: ${error.message}`;
        }
    }

    function formatDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffHours = Math.floor((now - date) / (1000 * 60 * 60));
        
        if (diffHours < 1) return 'Just now';
        if (diffHours < 24) return `${diffHours} hours ago`;
        return date.toLocaleDateString();
    }

    // === BACKUP FUNCTIONS ===
    function normalizeBackupData(data) {
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) {
          return null;
        }
      }
      
      if (Array.isArray(data)) {
        return {
          miraiChatHistory: JSON.stringify(data),
          _metadata: {
            version: 'legacy',
            persona: 'default',
            exportDate: new Date().toISOString()
          }
        };
      }
      
      if (data && typeof data === 'object' && !data._metadata) {
        if (Array.isArray(data.chatHistory) || Array.isArray(data.history)) {
          const chatArray = data.chatHistory || data.history || [];
          return {
            miraiChatHistory: JSON.stringify(chatArray),
            miraiPersona: data.persona || 'default',
            miraiLanguage: data.language || 'en',
            _metadata: {
              version: data.version || 'legacy-v2',
              persona: data.persona || 'default',
              exportDate: new Date().toISOString()
            }
          };
        }
        
        return {
          ...data,
          _metadata: {
            version: 'localStorage-format',
            exportDate: new Date().toISOString()
          }
        };
      }
      
      return data;
    }

    function restoreDataWithPersonaSync(originalData) {
      const data = normalizeBackupData(originalData);
      
      if (!data) {
        alert('‚ùå The backup file is invalid or corrupted!');
        return;
      }
      
      const metadata = data._metadata || {};
      const backupPersona = metadata.persona || data.miraiPersona || 'default';
      const backupLanguage = metadata.language || currentLanguage;
      
      const hasSignature = data._signature && 
                          data._signature.headerText && 
                          data._signature.headerCode;
      
      let verificationStatus = '';
      if (hasSignature) {
        const HEADER_TEXT = MIRAI_CONFIG.HEADER_TEXT;
        
        if (data._signature.headerText === HEADER_TEXT) {
          verificationStatus = '‚úÖ VERIFIED - Authentic files from MirAI';
        } else {
          verificationStatus = '‚ö†Ô∏è WARNING - Invalid signature';
        }
      } else {
        verificationStatus = '‚ö†Ô∏è WARNING - File does not have authenticity signature';
      }
      
      console.log('Restoring backup:', {
        persona: backupPersona,
        language: backupLanguage,
        metadata: metadata,
        hasSignature: hasSignature,
        verificationStatus: verificationStatus
      });
      
      const dataToStore = { ...data };
      delete dataToStore._metadata;
      delete dataToStore._signature;
      
      localStorage.clear();
      
      Object.keys(dataToStore).forEach(key => {
        if (key && dataToStore[key] !== null && dataToStore[key] !== undefined) {
          localStorage.setItem(key, dataToStore[key]);
        }
      });
      
      const restoredHistory = localStorage.getItem('miraiChatHistory');
      
      if (restoredHistory) {
        try {
          let chatHistory = JSON.parse(restoredHistory);
          
          chatHistory = chatHistory.filter(item => {
            if (item.parts && item.parts[0] && item.parts[0].text) {
              const text = item.parts[0].text.toLowerCase();
              const isPersonaPrompt = 
                text.includes('you are mirai') ||
                text.includes('system instruction') ||
                text.includes('[persona:') ||
                text.includes('personality');
              return !isPersonaPrompt;
            }
            return true;
          });
          
          const lang = backupLanguage || localStorage.getItem('miraiLanguage') || 'en';
          const personaPromptText = getPersonaPrompt(backupPersona);
          
          if (personaPromptText) {
            chatHistory.unshift({ 
              role: "user", 
              parts: [{ 
                text: `[PERSONA: ${backupPersona.toUpperCase()}]\n${personaPromptText}` 
              }] 
            });
            
            console.log('‚úÖ Added persona prompt:', backupPersona);
          }
          
          localStorage.setItem('miraiChatHistory', JSON.stringify(chatHistory));
          
        } catch (e) {
          console.error('Error during persona sync:', e);
        }
      }
      
      if (backupPersona) localStorage.setItem('miraiPersona', backupPersona);
      if (backupLanguage && uiStrings[backupLanguage]) {
        localStorage.setItem('miraiLanguage', backupLanguage);
      }
      
      const restoredChats = restoredHistory ? JSON.parse(restoredHistory).length : 0;
      const successMsg = `‚úÖ BACKUP RESTORED SUCCESSFUL!\n\n` +
                        `‚Ä¢ Persona: ${backupPersona}\n` +
                        `‚Ä¢ Language: ${backupLanguage}\n` +
                        `‚Ä¢ Chat: ${restoredChats} messages\n` +
                        `‚Ä¢ Verification: ${verificationStatus}\n\n` +
                        `App will be reloading...`;
      
      alert(successMsg);
      
      setTimeout(() => {
        console.log('Reloading application after restore...');
        location.reload();
        // ‚≠ê‚≠ê FIX: Force update UI after reload
        setTimeout(() => {
            const savedMaxBubbles = localStorage.getItem('miraiMaxBubbles') || '50';
            if (elements && elements.memorySlider) {
                updateMemorySliderUI(savedMaxBubbles);
            }
        }, 100);
      }, 800);
    }

    // === FUNGSI LIMIT API PUBLIK ===
    function isPublicApiKey(apiKey) {
        return apiKey === DEFAULT_API_KEY;
    }

    function showApiLimitPopup(level, bubbleCount) {
        const lang = uiStrings[currentLanguage];
        
        let message, showSettingsBtn = false;
        
        if (level === 'warning') {
            message = `‚ö†Ô∏è PUBLIC FIRE LIMIT WARNING\n\n` +
                     `You have used ${bubbleCount} bubbles with public API Key.\n` +
                     `The maximum limit is ${MEDF_PROCESSOR.PUBLIC_API_LIMITS.MAX_BUBBLES_WARNING} bubbles.\n\n` +
                     `To continue unlimited chat, please use your personal API Key.`;
        } else if (level === 'block') {
            message = `üö´ PUBLIC API BLOCKED\n\n` +
                     `You have reached the limit ${bubbleCount} bubbles with public API Key.\n` +
                     `Access to the public API is now disabled.\n\n` +
                     `To continue using MirAI, please enter your personal API Key.`;
            showSettingsBtn = true;
        }
        
        const popupOverlay = document.createElement('div');
        popupOverlay.id = 'apiLimitPopup';
        popupOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            animation: fadeIn 0.3s ease;
        `;
        
        const popupContent = document.createElement('div');
        popupContent.style.cssText = `
            background: var(--srui-bg-primary, #1a1a1a);
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 2px solid ${level === 'warning' ? '#ff9800' : '#f44336'};
        `;
        
        const messageEl = document.createElement('p');
        messageEl.style.cssText = `
            color: var(--srui-text-primary, #fff);
            margin-bottom: 20px;
            line-height: 1.5;
            white-space: pre-line;
        `;
        messageEl.textContent = message;
        
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        `;
        
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.cssText = `
            background: #666;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        `;
        closeBtn.onclick = () => {
            document.body.removeChild(popupOverlay);
        };
        
        popupContent.appendChild(messageEl);
        
        if (showSettingsBtn) {
            const settingsBtn = document.createElement('button');
            settingsBtn.textContent = 'Install My API Key';
            settingsBtn.style.cssText = `
                background: #4285f4;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
                display: flex;
                align-items: center;
                gap: 8px;
                margin: 10px auto;
            `;
            settingsBtn.onclick = () => {
                document.body.removeChild(popupOverlay);
                if (window.location.hash !== '#settings') {
                    history.pushState({ settings: true }, '', '#settings');
                    setTimeout(handleHashNavigation, 50);
                }
            };
            popupContent.appendChild(settingsBtn);
        }
        
        popupContent.appendChild(buttonContainer);
        buttonContainer.appendChild(closeBtn);
        popupOverlay.appendChild(popupContent);
        
        document.body.appendChild(popupOverlay);
    }

    function checkAndUpdatePublicApiLimit() {
        if (!isUsingPublicApi) return true;
        
        const bubbleCount = MEDF_PROCESSOR.countPublicApiBubbles();
        
        if (bubbleCount === MEDF_PROCESSOR.PUBLIC_API_LIMITS.MAX_BUBBLES_WARNING) {
            console.log('‚ö†Ô∏è Public API warning limit reached');
            setTimeout(() => {
                showApiLimitPopup('warning', bubbleCount);
            }, 1000);
        }
        
        if (bubbleCount >= MEDF_PROCESSOR.PUBLIC_API_LIMITS.MAX_BUBBLES_BLOCK) {
            console.log('üö´ Public API blocked - maximum limit reached');
            setTimeout(() => {
                showApiLimitPopup('block', bubbleCount);
            }, 1000);
            return false;
        }
        
        return true;
    }

    function trackPublicApiUsage() {
        if (isUsingPublicApi) {
            const newCount = MEDF_PROCESSOR.incrementPublicApiBubbles();
            console.log(`üìà Public API bubble count: ${newCount}`);
        }
    }

// ‚≠ê‚≠ê BARU: Load search config ke UI elements
function loadSearchConfigToUI() {
    console.log('üîÑ Loading search config to UI...');
    
    if (!elements.searchapiApiKey) return;
    
    // Update UI fields dari SEARCH_CONFIG
    elements.searchapiApiKey.value = SEARCH_CONFIG.engines.searchapi.apiKey || '';
    elements.googleApiKey.value = SEARCH_CONFIG.engines.google.apiKey || '';
    elements.googleCx.value = SEARCH_CONFIG.engines.google.cx || '';
    elements.enableSearchAPI.checked = SEARCH_CONFIG.engines.searchapi.enabled;
    elements.enableGoogleSearch.checked = SEARCH_CONFIG.engines.google.enabled;
    elements.enableDuckDuckGo.checked = SEARCH_CONFIG.engines.duckduckgo.enabled;
    elements.enableWikipedia.checked = SEARCH_CONFIG.engines.wikipedia.enabled;
    
    console.log('‚úÖ UI elements updated with search config');
}

// === FUNGSI BARU UNTUK SEARCH ENGINE FLOW ===

// Fungsi untuk cek apakah ada search engine yang aktif
function checkAnySearchEngineEnabled() {
    return Object.values(SEARCH_CONFIG.engines).some(engine => engine.enabled);
}

// Fungsi untuk get enabled engines count
function getEnabledEnginesCount() {
    return Object.values(SEARCH_CONFIG.engines).filter(engine => engine.enabled).length;
}

// Fungsi untuk save search config ke localStorage
function saveSearchConfigToLocalStorage() {
    const config = {};
    Object.keys(SEARCH_CONFIG.engines).forEach(key => {
        config[key] = {
            enabled: SEARCH_CONFIG.engines[key].enabled,
            apiKey: SEARCH_CONFIG.engines[key].apiKey || '',
            cx: SEARCH_CONFIG.engines[key].cx || ''
        };
    });
    localStorage.setItem('miraiSearchConfig', JSON.stringify(config));
}

// Fungsi update info di settings
function updateSearchModeInfo() {
    const infoElement = document.getElementById('searchModeInfo');
    if (!infoElement) return;
    
    const enabledCount = getEnabledEnginesCount();
    const lang = uiStrings[currentLanguage];
    
    // Check which engines are configured
    const searchapiReady = SEARCH_CONFIG.engines.searchapi.enabled && 
                          SEARCH_CONFIG.engines.searchapi.apiKey;
    const googleReady = SEARCH_CONFIG.engines.google.enabled && 
                       SEARCH_CONFIG.engines.google.apiKey && 
                       SEARCH_CONFIG.engines.google.cx;
    const duckduckgoReady = SEARCH_CONFIG.engines.duckduckgo.enabled;
    const wikipediaReady = SEARCH_CONFIG.engines.wikipedia.enabled;
    
    if (enabledCount === 0) {
        infoElement.innerHTML = `
            <div class="search-mode-indicator ai">
                <span class="engine-status-dot active"></span>
                ${lang.searchModeAI}
            </div>
            <div style="margin-top: 8px; font-size: 0.8em;">
                <small style="color: var(--srui-text-secondary);">${lang.searchModeDescAI}</small>
                <br>
                <small style="color: var(--srui-warning); margin-top: 5px; display: block;">
                    <i class="fas fa-triangle-exclamation"></i> External search engines disabled
                </small>
            </div>
        `;
    } else {
        let enginesHtml = '';
        let activeEngines = 0;
        
        if (searchapiReady) {
            enginesHtml += `<div><span class="engine-status-dot active"></span> SearchAPI.io</div>`;
            activeEngines++;
        }
        if (googleReady) {
            enginesHtml += `<div><span class="engine-status-dot active"></span> Google Search</div>`;
            activeEngines++;
        }
        if (duckduckgoReady) {
            enginesHtml += `<div><span class="engine-status-dot active"></span> DuckDuckGo</div>`;
            activeEngines++;
        }
        if (wikipediaReady) {
            enginesHtml += `<div><span class="engine-status-dot active"></span> Wikipedia</div>`;
            activeEngines++;
        }
        
        infoElement.innerHTML = `
            <div class="search-mode-indicator external">
                <span class="engine-status-dot active"></span>
                ${lang.searchModeExternal}
            </div>
            <div style="margin-top: 10px; font-size: 0.8em;">
                <div style="color: var(--srui-text-secondary); margin-bottom: 5px;">
                    ${activeEngines}/${enabledCount} engines ready
                </div>
                <div style="background: rgba(255, 206, 0, 0.05); padding: 8px; border-radius: 6px; font-size: 0.75em;">
                    ${enginesHtml}
                </div>
                <small style="color: var(--srui-text-tertiary); margin-top: 8px; display: block;">
                    ${lang.searchModeDescExternal}
                </small>
            </div>
        `;
    }
}

    // --- FUNGSI UTAMA MIRAI ---
    function initializeSlashCommands(lang) {
        const s = uiStrings[lang];
        slashCommands = [
            { command: '/search', title: s.slashCmdSearchTitle, description: '/search [search query]' },
            { command: '/translate', title: s.slashCmdTranslateTitle, description: '/translate [text] to [language]' },
            { command: '/summarize', title: s.slashCmdSummarizeTitle, description: '/summarize [long text]' },
            { command: '/rephrase', title: s.slashCmdRephraseTitle, description: '/rephrase [text] as [tone]' },
            { command: '/ideate', title: s.slashCmdIdeateTitle, description: '/ideate [amount] ideas for [topic]' },
            { command: '/fix', title: s.slashCmdFixTitle, description: '/fix [text that needs to be corrected]' },
            { command: '/explain', title: s.slashCmdExplainTitle, description: '/explain [concept] like I\'m [audience]' },
            { command: '/code', title: s.slashCmdCodeTitle, description: '/code a [programming language] function to [description]' }
        ];
    }

    function convertImageToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => {
                const base64String = reader.result.split(',')[1];
                resolve(base64String);
            };
            reader.onerror = error => reject(error);
        });
    }

    function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.type.startsWith('image/')) {
            alert(uiStrings[currentLanguage].invalidImageText);
            return;
        }

        elements.imageInput.value = '';

        convertImageToBase64(file)
            .then(base64Data => {
                currentImageData = {
                    mimeType: file.type,
                    data: base64Data
                };
                
                elements.imagePreview.src = `data:${file.type};base64,${base64Data}`;
                elements.imagePreviewContainer.style.display = 'flex';
                toggleChatUI(true);
                updateSendButtonState();
            })
            .catch(error => {
                console.error('Error converting image:', error);
                removeImage();
            });
    }

    function removeImage() {
        currentImageData = null;
        elements.imagePreview.src = '';
        elements.imagePreviewContainer.style.display = 'none';
        elements.imageInput.value = '';
        updateSendButtonState();
    }

    function getPersonaPrompt(personaType) {
        if (personaType === 'custom') {
            const customText = localStorage.getItem('miraiCustomPersona') || '';
            if (currentLanguage === 'id') {
                return `Anda adalah MirAI, Asisten AI, ${customText}`;
            } else if (currentLanguage === 'jp') {
                return `„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅAI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÅ${customText}`;
            } else {
                return `You are MirAI, an AI Assistant, ${customText}`;
            }
        }
        
        const promptKey = `persona${personaType.charAt(0).toUpperCase() + personaType.slice(1)}Prompt`;
        return uiStrings[currentLanguage][promptKey] || uiStrings['en'][promptKey];
    }

    async function initializeApp() {
    console.log('üîß Initializing app...');
    
    try {
        // Load API Key dari config.medf
        currentApiKey = await MEDF_PROCESSOR.loadEncryptedApiKey();
        console.log('üîë API Key loaded from config.medf:', currentApiKey.substring(0, 10) + '...');
        
        // ‚≠ê‚≠ê BARU: Load search config dari encrypted file
        loadSearchConfigFromEncrypted();
        
    } catch (error) {
        console.error('Failed to load API key from config.medf:', error);
        currentApiKey = DEFAULT_API_KEY;
    }
    
    isUsingPublicApi = isPublicApiKey(currentApiKey);
    console.log(`üåê Using ${isUsingPublicApi ? 'PUBLIC' : 'PRIVATE'} API Key`);
    
    if (isUsingPublicApi) {
        const bubbleCount = MEDF_PROCESSOR.countPublicApiBubbles();
        console.log(`üìä Public API usage: ${bubbleCount} bubbles used`);
        
        if (bubbleCount >= MEDF_PROCESSOR.PUBLIC_API_LIMITS.MAX_BUBBLES_WARNING) {
            setTimeout(() => {
                showApiLimitPopup('warning', bubbleCount);
            }, 2000);
        }
    }
    
    const savedLang = localStorage.getItem('miraiLanguage');
    if (savedLang && uiStrings.hasOwnProperty(savedLang)) {
        currentLanguage = savedLang;
    } else {
        currentLanguage = 'en';
    }

    currentPersona = localStorage.getItem('miraiPersona') || 'default';
    const savedTheme = localStorage.getItem('miraiTheme') || 'dark';
    const savedApiKey = localStorage.getItem('miraiApiKey');
    
    elements.langDropdown.value = currentLanguage;
    elements.personaSelect.value = currentPersona;
    
    if (savedApiKey) {
        currentApiKey = savedApiKey;
        elements.apiKeyInput.value = savedApiKey;
        console.log('üîë Using API Key from localStorage');
        isUsingPublicApi = isPublicApiKey(currentApiKey);
    }

    const savedCustomPersona = localStorage.getItem('miraiCustomPersona');
    if (savedCustomPersona) {
        currentPersona = 'custom';
        elements.personaSelect.value = 'custom';
        elements.customPersonaContainer.style.display = 'block';
        elements.customPersonaInput.value = savedCustomPersona;
    }

    // Initialize memory slider - FIXED: Show actual counts
    const savedMaxBubbles = localStorage.getItem('miraiMaxBubbles') || '50';
    elements.memorySlider.value = savedMaxBubbles;
    tempMaxBubbles = parseInt(savedMaxBubbles);
    
    console.log(`üìä Memory limit set to ${tempMaxBubbles} (not applied yet)`);
    
    // ‚≠ê‚≠ê BARU: Jika ini kunjungan pertama, disable semua search engine
    const isFirstVisit = !localStorage.getItem('miraiSearchConfig');
    if (isFirstVisit) {
        console.log('üëã First-time user: Disabling all search engines by default');
        
        // Nonaktifkan semua search engine
        Object.keys(SEARCH_CONFIG.engines).forEach(engine => {
            SEARCH_CONFIG.engines[engine].enabled = false;
        });
        
        // Simpan ke localStorage
        saveSearchConfigToLocalStorage();
        
        console.log('‚úÖ All search engines disabled for first-time user');
    }

    initializeSlashCommands(currentLanguage);
    setTheme(savedTheme);
    updateUI();
    
    const historyLoaded = loadChatHistory();
    if (!historyLoaded) {
        initializeNewChatSession();
    }
    
    // ‚≠ê‚≠ê BARU: Load UI config untuk settings panel (setelah load dari encrypted file)
    loadSearchConfigToUI();
    
    // ‚≠ê‚≠ê BARU: Update search mode info
    updateSearchModeInfo();
    
    // ‚≠ê‚≠ê CRITICAL FIX: Update memory slider UI AFTER loading chat history
    updateMemorySliderUI(savedMaxBubbles);
    
    if (isBeta) {
        const versionText = document.getElementById('settingsVersionText');
        if (versionText) {
            versionText.innerText += '\n3FlashPreviewMode';
            versionText.style.color = '#00ff00';
        }
    }
}

    function loadSearchConfig() {
        const savedSearchConfig = localStorage.getItem('miraiSearchConfig');
        if (savedSearchConfig) {
            try {
                const config = JSON.parse(savedSearchConfig);
                Object.keys(config).forEach(key => {
                    if (SEARCH_CONFIG.engines[key]) {
                        SEARCH_CONFIG.engines[key] = { ...SEARCH_CONFIG.engines[key], ...config[key] };
                    }
                });
                console.log('‚úÖ Search config loaded');
                
                elements.searchapiApiKey.value = SEARCH_CONFIG.engines.searchapi.apiKey || '';
                elements.googleApiKey.value = SEARCH_CONFIG.engines.google.apiKey || '';
                elements.googleCx.value = SEARCH_CONFIG.engines.google.cx || '';
                elements.enableSearchAPI.checked = SEARCH_CONFIG.engines.searchapi.enabled;
                elements.enableGoogleSearch.checked = SEARCH_CONFIG.engines.google.enabled;
                elements.enableDuckDuckGo.checked = SEARCH_CONFIG.engines.duckduckgo.enabled;
                elements.enableWikipedia.checked = SEARCH_CONFIG.engines.wikipedia.enabled;
                
            } catch (e) {
                console.error('Error loading search config:', e);
            }
        }
    }

function saveSearchConfig() {
    const config = {
        searchapi: {
            apiKey: elements.searchapiApiKey.value.trim(),
            enabled: elements.enableSearchAPI.checked,
            engine: 'google'
        },
        google: {
            apiKey: elements.googleApiKey.value.trim(),
            cx: elements.googleCx.value.trim(),
            enabled: elements.enableGoogleSearch.checked
        },
        duckduckgo: {
            enabled: elements.enableDuckDuckGo.checked
        },
        wikipedia: {
            enabled: elements.enableWikipedia.checked
        }
    };
    
    console.log('üíæ Saving search config:', config);
    
    // ‚≠ê‚≠ê BARU: Simpan ke SEARCH_CONFIG (memory)
    Object.keys(config).forEach(key => {
        if (SEARCH_CONFIG.engines[key]) {
            SEARCH_CONFIG.engines[key] = { ...SEARCH_CONFIG.engines[key], ...config[key] };
        }
    });
    
    // Simpan ke localStorage
    localStorage.setItem('miraiSearchConfig', JSON.stringify(config));
    
    // ‚≠ê‚≠ê BARU: Update search mode info
    updateSearchModeInfo();
    
    // ‚≠ê‚≠ê BARU: Berikan feedback berdasarkan status
    const enabledCount = getEnabledEnginesCount();
    let message = 'Search configuration saved! ';
    
    if (enabledCount === 0) {
        message += 'All search engines disabled. /search will use AI knowledge base.';
    } else {
        message += `${enabledCount} search engine(s) enabled.`;
    }
    
    console.log('‚úÖ Search config saved to localStorage and SEARCH_CONFIG');
    console.log('üîç Current SEARCH_CONFIG.engines.searchapi:', {
        hasApiKey: !!SEARCH_CONFIG.engines.searchapi.apiKey,
        apiKeyPreview: SEARCH_CONFIG.engines.searchapi.apiKey?.substring(0, 10) + '...'
    });
    
    showCopyFeedback(message);
}

function testSearch() {
    const enabledCount = getEnabledEnginesCount();
    const lang = uiStrings[currentLanguage];
    
    if (enabledCount === 0) {
        // AI Knowledge Base mode
        const testMsg = document.createElement('div');
        testMsg.className = 'chat-bubble ai-bubble';
        testMsg.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <span style="background: rgba(76, 175, 80, 0.2); color: #4CAF50; padding: 4px 12px; border-radius: 20px; font-size: 0.9em;">
                    üîç AI Knowledge Base Mode
                </span>
            </div>
            <div style="color: var(--srui-text-secondary); font-size: 0.9em; margin-bottom: 10px;">
                Testing search using AI's training data only...
            </div>
        `;
        elements.chatMessages.appendChild(testMsg);
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
        
        setTimeout(() => {
            testMsg.innerHTML += `
                <div style="margin-top: 15px; padding: 10px; background: rgba(76, 175, 80, 0.1); border-radius: 8px; border-left: 3px solid #4CAF50;">
                    <strong><i class="fas fa-list-check"></i> AI Knowledge Base mode active</strong>
                    <div style="margin-top: 5px; font-size: 0.9em;">
                        Your search would be answered using AI's training data.<br>
                        <span style="color: var(--srui-warning);">
                            Enable external search engines in Settings for real-time internet results.
                        </span>
                    </div>
                </div>
            `;
            elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
        }, 1000);
        return;
    }
    
    const query = 'artificial intelligence';
    
    // ‚≠ê‚≠ê BARU: Check jika search engine configured
    const searchapiReady = SEARCH_CONFIG.engines.searchapi.enabled && 
                          SEARCH_CONFIG.engines.searchapi.apiKey && 
                          SEARCH_CONFIG.engines.searchapi.apiKey.trim() !== '' &&
                          !SEARCH_CONFIG.engines.searchapi.apiKey.includes('YOUR_');
    
    const googleReady = SEARCH_CONFIG.engines.google.enabled && 
                       SEARCH_CONFIG.engines.google.apiKey && 
                       SEARCH_CONFIG.engines.google.apiKey.trim() !== '' &&
                       !SEARCH_CONFIG.engines.google.apiKey.includes('YOUR_') &&
                       SEARCH_CONFIG.engines.google.cx && 
                       SEARCH_CONFIG.engines.google.cx.trim() !== '' &&
                       !SEARCH_CONFIG.engines.google.cx.includes('YOUR_');
    
    const duckduckgoReady = SEARCH_CONFIG.engines.duckduckgo.enabled;
    const wikipediaReady = SEARCH_CONFIG.engines.wikipedia.enabled;
    
    // Pilih engine yang available (SearchAPI.io sebagai default)
    let engine = 'searchapi';
    if (searchapiReady) {
        engine = 'searchapi';
    } else if (googleReady) {
        engine = 'google';
    } else if (duckduckgoReady) {
        engine = 'duckduckgo';
    } else if (wikipediaReady) {
        engine = 'wikipedia';
    } else {
        engine = 'none';
    }
    
    if (engine === 'none') {
        let message = `üîç ${lang.searchEngineNotConfigured}\n\n`;
        message += `Available engines:\n`;
        message += `‚Ä¢ SearchAPI.io (Default): ${searchapiReady ? '‚úÖ Ready' : '‚ùå Not configured'}\n`;
        message += `‚Ä¢ Google Search (Secondary): ${googleReady ? '‚úÖ Ready' : '‚ùå Not configured'}\n`;
        message += `‚Ä¢ DuckDuckGo: ${duckduckgoReady ? '‚úÖ Enabled' : '‚ùå Disabled'}\n`;
        message += `‚Ä¢ Wikipedia: ${wikipediaReady ? '‚úÖ Enabled' : '‚ùå Disabled'}\n\n`;
        
        if (!searchapiReady) {
            message += `To configure SearchAPI.io (Recommended):\n`;
            message += `1. Get API Key from: https://www.searchapi.io\n`;
            message += `2. Free tier: 100 searches/month\n`;
            message += `3. Enter in Settings ‚Üí Search Configuration\n`;
        }
        
        alert(message);
        return;
    }
    
    const testMsg = document.createElement('div');
    testMsg.className = 'chat-bubble ai-bubble';
    testMsg.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span style="background: rgba(66, 133, 244, 0.2); color: #4285f4; padding: 4px 12px; border-radius: 20px; font-size: 0.9em;">
                üîç ${engine.toUpperCase()} Search Mode
            </span>
        </div>
        <div style="color: var(--srui-text-secondary); font-size: 0.9em; margin-bottom: 10px;">
            ${lang.searchTestResult}${engine}...
        </div>
    `;
    elements.chatMessages.appendChild(testMsg);
    elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
    
    console.log(`üß™ Testing search with engine: ${engine}`);
    
    performExternalSearch(query, engine, 2)
        .then(result => {
            testMsg.innerHTML += `
                <div style="margin-top: 15px; padding: 10px; background: rgba(66, 133, 244, 0.1); border-radius: 8px; border-left: 3px solid #4285f4;">
                    <div style="font-size: 0.9em; white-space: pre-line;">${result}</div>
                </div>
            `;
            elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
        })
        .catch(error => {
            testMsg.innerHTML += `
                <div style="margin-top: 15px; padding: 10px; background: rgba(244, 67, 54, 0.1); border-radius: 8px; border-left: 3px solid #F44336;">
                    <strong>‚ùå Test failed:</strong> ${error.message}
                </div>
            `;
            elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
        });
}

    function initializeNewChatSession() {
        const personaPromptText = getPersonaPrompt(currentPersona);
        chatHistory = [{ role: "user", parts: [{ text: personaPromptText }] }];
        console.log('Sesi chat baru dimulai dengan persona:', currentPersona);
    }

    // FIXED: loadChatHistory without auto-slicing
    function loadChatHistory() {
        const savedHistory = localStorage.getItem('miraiChatHistory');
        if (savedHistory) {
            try {
                const maxBubbles = parseInt(localStorage.getItem('miraiMaxBubbles') || '50');
                
                let parsedHistory = JSON.parse(savedHistory);
                
                // ‚≠ê‚≠ê FIX: Just load the history, don't adjust slider
                chatHistory = parsedHistory;
                
                console.log('Chat history loaded successfully.', chatHistory.length, 'messages');
                return true;
                
            } catch (e) {
                console.error('Error parsing chat history:', e);
                return false;
            }
        }
        console.log('No chat history to load.');
        return false;
    }

    function saveChatHistory() {
        // FIXED: Only save current history, don't auto-slice
        localStorage.setItem('miraiChatHistory', JSON.stringify(chatHistory));
    }

    function clearChat() {
        elements.chatMessages.innerHTML = '';
        localStorage.removeItem('miraiChatHistory');
        initializeNewChatSession();
        toggleChatUI(false);
        updateDynamicPlaceholder();
        updateMemorySliderUI(elements.memorySlider.value);
        
        if (window.speechSynthesis.speaking) {
            window.speechSynthesis.cancel();
        }
    }

    function showClearConfirmation() {
        const lang = uiStrings[currentLanguage];
        elements.customConfirmMessage.innerText = lang.confirmClearMessage;
        elements.confirmBtnYes.innerText = lang.confirmClearYes;
        elements.confirmBtnNo.innerText = lang.confirmClearNo;
        elements.customConfirmOverlay.classList.add('visible');
    }

    function hideClearConfirmation() {
        elements.customConfirmOverlay.classList.remove('visible');
    }

    function setPersona(persona, fromUserInteraction = false) {
        currentPersona = persona;
        elements.personaSelect.value = persona;
        localStorage.setItem('miraiPersona', persona);
        
        if (persona === 'custom') {
            elements.customPersonaContainer.style.display = 'block';
            const savedCustomPrompt = localStorage.getItem('miraiCustomPersona');
            if (savedCustomPrompt) {
                elements.customPersonaInput.value = savedCustomPrompt;
            }
        } else {
            elements.customPersonaContainer.style.display = 'none';
        }
        
        if (chatHistory.length > 0 && chatHistory[0].role === "user") {
            const personaPromptText = getPersonaPrompt(persona);
            chatHistory[0].parts[0].text = personaPromptText;
            saveChatHistory();
        }
    }

    function setLanguage(lang, fromUserInteraction = false) {
        currentLanguage = lang;
        elements.langDropdown.value = lang;
        localStorage.setItem('miraiLanguage', lang);
        initializeSlashCommands(currentLanguage);
        populateToolsMenu();
        updateUI();
        // ‚≠ê‚≠ê BARU: Update search mode info saat ganti bahasa
        updateSearchModeInfo();
    }

    async function askAI() {
        const userQuestion = elements.questionInput.value;

        if (userQuestion.trim() === '' && !currentImageData) return;

        if (isUsingPublicApi && !checkAndUpdatePublicApiLimit()) {
            toggleChatUI(false);
            elements.sendBtn.style.display = 'block';
            elements.stopBtn.style.display = 'none';
            elements.clearBtnContainer.style.display = 'block';
            return;
        }

        const clientDateTime = getCurrentDateTimeString();
        const promptTemplate = uiStrings[currentLanguage].dateTimeContextPrompt;
        const contextPrompt = promptTemplate.replace('{dateTime}', clientDateTime);
        
        let promptToSendToAI;

        if (!currentImageData) {
            const processedPrompt = await handleSlashCommand(userQuestion);
            if (processedPrompt !== null) {
                if (processedPrompt.startsWith('Error:')) {
                    return;
                }
                promptToSendToAI = `${contextPrompt}\n\n"${processedPrompt}"`;
            } else {
                promptToSendToAI = `${contextPrompt}\n\n"${userQuestion}"`;
            }
        } else {
            promptToSendToAI = `${contextPrompt}\n\n"${userQuestion}"`;
        }

        toggleChatUI(true);
        elements.questionInput.value = '';
        elements.questionInput.style.height = 'auto';
        elements.suggestionBox.classList.remove('visible');
        updateSendButtonState();
        elements.sendBtn.style.display = 'none';
        elements.clearBtnContainer.style.display = 'none';
        elements.stopBtn.style.display = 'block';

        const userBubble = document.createElement('div');
        userBubble.classList.add('chat-bubble', 'user-bubble');
        
        let userBubbleHTML = '';
        if (currentImageData) {
            userBubbleHTML += `<img src="${elements.imagePreview.src}" style="width: 100%; max-width: 200px; border-radius: 10px; margin-bottom: 5px;"><br>`;
        }
        
        const textNode = document.createTextNode(userQuestion);
        userBubble.appendChild(textNode);
        
        if(currentImageData) {
            userBubble.innerHTML = userBubbleHTML;
            userBubble.appendChild(document.createElement('br'));
            userBubble.appendChild(textNode);
        }

        elements.chatMessages.appendChild(userBubble);
        setTimeout(() => userBubble.classList.add('fade-in'), 10);
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;

        const userParts = [];
        userParts.push({ text: promptToSendToAI });

        if (currentImageData) {
            userParts.push({
                inlineData: {
                    mimeType: currentImageData.mimeType,
                    data: currentImageData.data
                }
            });
        }
        
        chatHistory.push({ role: "user", parts: userParts });
        saveChatHistory();
        
        const imageWasSent = !!currentImageData;
        removeImage();

        const loadingBubble = showLoading();

        if (!imageWasSent) {
            const localAnswer = findSmartAnswer(userQuestion);
            if (localAnswer) {
                completeLoading(loadingBubble);
                setTimeout(() => {
                    loadingBubble.remove();
                    // PERBAIKAN: Gunakan createAiBubble dengan true untuk static content
                    const aiBubble = createAiBubble(localAnswer, true);
                    elements.chatMessages.appendChild(aiBubble);
                    elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
                    elements.sendBtn.style.display = 'block';
                    elements.stopBtn.style.display = 'none';
                    elements.clearBtnContainer.style.display = 'block';
                }, 500);
                return;
            }
        }

        try {
            abortController = new AbortController();
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${currentApiKey}`;
            
            const requestBody = { contents: chatHistory };

            const response = await fetch(url, { 
                method: "POST", 
                headers: { "Content-Type": "application/json" }, 
                body: JSON.stringify(requestBody), 
                signal: abortController.signal 
            });
            
            if (!response.ok) { 
                throw new Error(`HTTP error! status: ${response.status}`); 
            }
            
            const data = await response.json();
            let answer = uiStrings[currentLanguage].errorFallback;
            
            if (data.candidates?.[0]?.content?.parts?.[0]) {
                answer = data.candidates[0].content.parts[0].text;
                chatHistory.push({ role: "model", parts: [{ text: answer }] });
                saveChatHistory();
                
                if (isUsingPublicApi) {
                    trackPublicApiUsage();
                }
            }
            
            const processingTime = completeLoading(loadingBubble);
            setTimeout(() => {
                loadingBubble.remove();
                // PERBAIKAN: Gunakan createAiBubble dengan false untuk dynamic content
                const aiBubble = createAiBubble(answer, false);
                elements.chatMessages.appendChild(aiBubble);
                // PERBAIKAN: Typewriter effect akan mengisi .message-content
                typeWriterEffect(aiBubble, answer).then(() => {
                    elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
                    elements.sendBtn.style.display = 'block';
                    elements.stopBtn.style.display = 'none';
                    elements.clearBtnContainer.style.display = 'block';
                });
                
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
            }, 800);
            
        } catch (error) {
            console.error('Error:', error);
            if (error.name !== 'AbortError') {
                const errorMessage = navigator.onLine ? uiStrings[currentLanguage].errorAPI : uiStrings[currentLanguage].errorConnection;
                completeLoading(loadingBubble, false, 'Request failed');
                setTimeout(() => {
                    loadingBubble.remove();
                    const errorBubble = createAiBubble(errorMessage, true);
                    elements.chatMessages.appendChild(errorBubble);
                    elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
                }, 1000);
            }
            elements.sendBtn.style.display = 'block';
            elements.stopBtn.style.display = 'none';
            elements.clearBtnContainer.style.display = 'block';
        }
    }

    async function handleSlashCommand(question) { 
        if (!question.startsWith('/')) { return null; } 
        const parts = question.split(' '); 
        const command = parts[0].toLowerCase(); 
        
        switch (command) { 
            case '/search': { 
                const query = parts.slice(1).join(' ');
                if (!query) {
                    return "Error: Please provide a search query. Use /search [query]";
                }
                
                // ‚≠ê‚≠ê BARU: Cek apakah ada search engine yang aktif
                const isAnyEngineEnabled = checkAnySearchEngineEnabled();
                
                if (!isAnyEngineEnabled) {
                    // Mode AI Knowledge Base
                    console.log('üîç Search using AI Knowledge Base');
                    return `Based on my knowledge, answer this search query: "${query}". 
                    If you don't have sufficient information, acknowledge that and provide what you know. 
                    IMPORTANT: This answer comes from my training data only, not from external sources.`;
                }
                
                let searchEngine = SEARCH_CONFIG.defaultEngine;
                let resultCount = SEARCH_CONFIG.resultsPerPage;
                let searchType = 'web';
                
                const params = query.match(/\[(.*?)\]/g);
                let cleanQuery = query;
                
                if (params) {
                    params.forEach(param => {
                        const cleanParam = param.replace(/[\[\]]/g, '');
                        if (cleanParam.startsWith('engine:')) {
                            searchEngine = cleanParam.split(':')[1];
                        } else if (cleanParam.startsWith('results:')) {
                            resultCount = parseInt(cleanParam.split(':')[1]);
                        } else if (cleanParam.startsWith('type:')) {
                            searchType = cleanParam.split(':')[1];
                        }
                    });
                    cleanQuery = query.replace(/\[.*?\]/g, '').trim();
                }
                
                resultCount = Math.min(Math.max(1, resultCount), 10);
                
                const searchResult = await performExternalSearch(cleanQuery, searchEngine, resultCount, searchType);
                
                if (searchResult.startsWith('Error:')) {
                    return searchResult;
                }
                
                return `Search results for "${cleanQuery}":\n\n${searchResult}\n\nI've performed an external search. The results above are from ${searchEngine}.`;
            } 
            case '/translate': { 
                const toIndex = parts.indexOf('to'); 
                if (toIndex === -1 || toIndex < 2) { return "Error: Invalid format. Use /translate [text] to [language]"; } 
                const textToTranslate = parts.slice(1, toIndex).join(' '); 
                const targetLanguage = parts.slice(toIndex + 1).join(' '); 
                return `Translate the following text to ${targetLanguage}: "${textToTranslate}"`; 
            } 
            case '/summarize': { 
                const textToSummarize = parts.slice(1).join(' '); 
                if (textToSummarize.length < 20) { return "Error: Please provide more text to summarize."; } 
                return `Provide a concise summary of the following text: "${textToSummarize}"`; 
            } 
            case '/rephrase': { 
                const asIndex = parts.indexOf('as'); 
                if (asIndex === -1 || asIndex < 2) { return "Error: Invalid format. Use /rephrase [text] as [tone]"; } 
                const textToRephrase = parts.slice(1, asIndex).join(' '); 
                const tone = parts.slice(asIndex + 1).join(' '); 
                return `Rephrase the following text in a ${tone} tone: "${textToRephrase}"`; 
            } 
            case '/ideate': { 
                const forIndex = parts.indexOf('for'); 
                if (forIndex === -1 || forIndex < 3 || isNaN(parseInt(parts[1]))) { return "Error: Invalid format. Use /ideate [number] ideas for [topic]"; } 
                const number = parts[1]; 
                const topic = parts.slice(forIndex + 1).join(' '); 
                return `Generate ${number} ideas for ${topic}. Present them as a numbered list.`; 
            } 
            case '/fix': { 
                const textToFix = parts.slice(1).join(' '); 
                if (!textToFix) { return "Error: Please provide text to fix. Use /fix [text]"; } 
                return `Proofread and correct any grammatical errors and spelling mistakes in the following text. Only provide the corrected text: "${textToFix}"`; 
            } 
            case '/explain': { 
                const likeIndex = parts.findIndex(part => part.toLowerCase() === "like"); 
                if (likeIndex === -1 || likeIndex < 2) { return "Error: Invalid format. Use /explain [concept] like I\'m [audience]"; } 
                const concept = parts.slice(1, likeIndex).join(' '); 
                const audienceIndex = parts.indexOf("I'm") > -1 ? parts.indexOf("I'm") : parts.indexOf("i'm"); 
                if (audienceIndex === -1 || audienceIndex <= likeIndex) { return "Error: Invalid audience format. Use \"like I'm ...\""; } 
                const audience = parts.slice(audienceIndex + 1).join(' '); 
                return `Explain the concept of "${concept}" as if you were talking to a ${audience}.`; 
            } 
            case '/code': { 
                const toIndex = parts.indexOf('to'); 
                if (toIndex === -1 || toIndex < 3) { return "Error: Invalid format. Use /code a [language] function to [description]"; } 
                const language = parts[2]; 
                const description = parts.slice(toIndex + 1).join(' '); 
                return `Write a code snippet in ${language} for the following task: "${description}". Provide only the code, enclosed in a markdown code block.`; 
            } 
            default: return `Error: Unknown command "${command}". Try /translate or /summarize.`; 
        } 
    }

    function getCurrentDateTimeString() { 
        const now = new Date(); 
        const year = now.getFullYear(); 
        const month = String(now.getMonth() + 1).padStart(2, '0'); 
        const day = String(now.getDate()).padStart(2, '0'); 
        const hours = String(now.getHours()).padStart(2, '0'); 
        const minutes = String(now.getMinutes()).padStart(2, '0'); 
        const seconds = String(now.getSeconds()).padStart(2, '0'); 
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`; 
    }

    function populateToolsMenu() { 
        if (!elements.toolsMenu) return; 
        elements.toolsMenu.innerHTML = ''; 
        slashCommands.forEach(cmd => { 
            const menuItem = document.createElement('div'); 
            menuItem.classList.add('suggestion-item-slash'); 
            menuItem.innerHTML = `<strong>${cmd.command}</strong><span>${cmd.description}</span>`; 
            menuItem.addEventListener('click', () => { 
                elements.questionInput.value = cmd.command + ' '; 
                elements.toolsMenu.classList.remove('visible'); 
                elements.toolsBtn.classList.remove('active'); 
                elements.questionInput.focus(); 
            }); 
            elements.toolsMenu.appendChild(menuItem); 
        }); 
    }

    function updateSendButtonState() { 
        if (elements.questionInput.value.trim() === '' && !currentImageData) { 
            elements.sendBtn.classList.add('disabled'); 
            elements.sendBtn.disabled = true; 
        } else { 
            elements.sendBtn.classList.remove('disabled'); 
            elements.sendBtn.disabled = false; 
        } 
    }

    // FIXED: saveApiKey with manual memory limit application
    function saveApiKey() { 
        // Ask for confirmation before applying memory limit
        const savedLimit = localStorage.getItem('miraiMaxBubbles') || '50';
        
        if (tempMaxBubbles.toString() !== savedLimit) {
            const excessMessages = Math.max(0, (chatHistory.length - 1) - tempMaxBubbles);
            
            if (excessMessages > 0) {
                const lang = uiStrings[currentLanguage];
                const confirmMsg = `${lang.settingsMemoryWarning.replace('{count}', excessMessages)}\n\n` +
                                  `Apply new limit of ${tempMaxBubbles} bubbles?`;
                
                if (!confirm(confirmMsg)) {
                    // User cancelled - revert slider to original value
                    elements.memorySlider.value = savedLimit;
                    updateMemorySliderUI(savedLimit);
                    return;
                }
            }
            
            // Apply memory limit if changed and confirmed
            console.log(`üîß Applying new memory limit: ${savedLimit} ‚Üí ${tempMaxBubbles}`);
            applyMemoryLimit(tempMaxBubbles);
        }
        
        // Save other settings (API key, persona, etc.)
        const newKey = elements.apiKeyInput.value.trim(); 
        if (newKey) { 
            localStorage.setItem('miraiApiKey', newKey); 
            currentApiKey = newKey; 
            isUsingPublicApi = isPublicApiKey(currentApiKey);
            showCopyFeedback(uiStrings[currentLanguage].apiKeySaved); 
        } else { 
            localStorage.removeItem('miraiApiKey'); 
            currentApiKey = DEFAULT_API_KEY; 
            isUsingPublicApi = true;
            showCopyFeedback(uiStrings[currentLanguage].apiKeyRemoved); 
        }
        
        if (currentPersona === 'custom' && elements.customPersonaInput) {
            const customPrompt = elements.customPersonaInput.value.trim();
            if (customPrompt) {
                localStorage.setItem('miraiCustomPersona', customPrompt);
            } else {
                localStorage.removeItem('miraiCustomPersona');
            }
        }
        
        saveSearchConfig();
        
        const personaPromptText = getPersonaPrompt(currentPersona);
        if (chatHistory.length > 0 && chatHistory[0].role === "user") {
            chatHistory[0].parts[0].text = personaPromptText;
            saveChatHistory();
        }
        
        showCopyFeedback('Settings saved successfully!');
    }

    function toggleApiVisibility() { 
        const input = elements.apiKeyInput; 
        const icon = elements.toggleApiKey; 
        if (input.type === 'password') { 
            input.type = 'text'; 
            icon.classList.remove('fa-eye'); 
            icon.classList.add('fa-eye-slash'); 
        } else { 
            input.type = 'password'; 
            icon.classList.remove('fa-eye-slash'); 
            icon.classList.add('fa-eye'); 
        } 
    }

    function toggleSearchApiVisibility(targetId) {
        const input = document.getElementById(targetId);
        const icon = event.target;
        if (input.type === 'password') { 
            input.type = 'text'; 
            icon.classList.remove('fa-eye'); 
            icon.classList.add('fa-eye-slash'); 
        } else { 
            input.type = 'password'; 
            icon.classList.remove('fa-eye-slash'); 
            icon.classList.add('fa-eye'); 
        }
    }

    function updateConnectionStatus() { 
        if (navigator.onLine) { 
            elements.statusDot.classList.remove('offline'); 
            elements.statusDot.classList.add('online'); 
            elements.statusLabel.innerText = uiStrings[currentLanguage].onlineStatus; 
        } else { 
            elements.statusDot.classList.remove('online'); 
            elements.statusDot.classList.add('offline'); 
            elements.statusLabel.innerText = uiStrings[currentLanguage].offlineStatus; 
        } 
    }

    function updateUI() { 
        const lang = uiStrings[currentLanguage]; 
        elements.infoText.innerText = lang.infoText; 
        updateSettingsUI(); 
        updateDynamicPlaceholder(); 
        updateConnectionStatus(); 
        // ‚≠ê‚≠ê BARU: Update search mode info
        updateSearchModeInfo();
    }

    function updateDynamicPlaceholder() { 
        const placeholders = uiStrings[currentLanguage].placeholderMessages; 
        const randomIndex = Math.floor(Math.random() * placeholders.length); 
        elements.questionInput.placeholder = placeholders[randomIndex]; 
    }

    function updateSettingsUI() { 
        const lang = uiStrings[currentLanguage]; 
        if (!lang) return; 
        elements.settingsHeaderTitle.innerText = lang.settingsHeaderTitle; 
        elements.settingsAppearanceTitle.innerText = lang.settingsAppearanceTitle; 
        elements.settingsThemeText.innerText = lang.settingsThemeText; 
        elements.themeLightOption.innerText = lang.themeLightOption; 
        elements.themeDarkOption.innerText = lang.themeDarkOption; 
        elements.settingsAITitle.innerText = lang.settingsAITitle; 
        elements.settingsPersonaText.innerText = lang.settingsPersonaText; 
        elements.personaFormalOption.innerText = lang.personaFormalOption; 
        elements.personaDefaultOption.innerText = lang.personaDefaultOption; 
        elements.personaCreativeOption.innerText = lang.personaCreativeOption; 
        elements.personaCustomOption.innerText = lang.personaCustomOption; 
        elements.customPersonaHint.innerText = lang.customPersonaHint; 
        elements.customPersonaInput.placeholder = lang.customPersonaPlaceholder; 
        elements.settingsMemoryTitle.innerText = lang.settingsMemoryTitle; 
        elements.settingsMemoryText.innerText = lang.settingsMemoryText; 
        elements.settingsAboutTitle.innerText = lang.settingsAboutTitle; 
        elements.settingsVersionText.innerText = lang.settingsVersionText; 
        elements.settingsAuthorText.innerText = lang.settingsAuthorText; 
        elements.githubLink.innerText = lang.githubLink; 
        elements.licenseLink.innerText = lang.licenseLink; 
        elements.helpLink.innerText = lang.helpLink; 
        elements.termsText.innerHTML = lang.termsText; 
        elements.settingsApiTitle.innerText = lang.settingsApiTitle; 
        elements.settingsApiText.innerText = lang.settingsApiText; 
        document.title = lang.pageTitle; 
        elements.saveApiBtn.innerText = lang.saveApiKeyBtn; 
        elements.apiKeyInput.placeholder = lang.apiKeyPlaceholder; 
        elements.settingsSearchTitle.innerText = lang.settingsSearchTitle; 
        elements.searchConfigDesc.innerText = lang.searchConfigDesc; 
        elements.testSearchBtn.innerHTML = `<i class="fas fa-search"></i> ${lang.testSearchBtn}`; 
        elements.clearSearchCacheBtn.innerHTML = `<i class="fas fa-trash"></i> ${lang.clearSearchCacheBtn}`; 
    }

    function setTheme(theme) { 
        elements.body.classList.remove('light-theme', 'dark-theme'); 
        if (theme === 'light') { 
            elements.body.classList.add('light-theme'); 
        } else { 
            elements.body.classList.add('dark-theme'); 
        } 
        localStorage.setItem('miraiTheme', theme); 
        elements.themeSelect.value = theme; 
    }

    function handleHashNavigation() {
        const currentHash = window.location.hash;
        const settingsPanel = document.getElementById('settingsPanel');
        
        console.log('üîó Hash navigation:', currentHash);
        
        if (currentHash === '#settings') {
            if (settingsPanel) {
                settingsPanel.style.display = 'flex';
                document.body.style.overflow = 'hidden';
                console.log('‚úÖ Settings panel opened');
                // Update memory slider display when settings opened
                setTimeout(() => {
                    updateMemorySliderUI(elements.memorySlider.value);
                }, 100);
                // ‚≠ê‚≠ê BARU: Update search mode info saat settings dibuka
                updateSearchModeInfo();
            }
        } else {
            if (settingsPanel) {
                settingsPanel.style.display = 'none';
                document.body.style.overflow = '';
                console.log('‚ùå Settings panel closed');
            }
        }
    }

    function openSettings() {
        console.log('üéØ Opening settings...');
        
        if (window.location.hash === '#settings') return;
        
        sessionStorage.setItem('mainScrollPos', window.scrollY);
        
        history.pushState({ settings: true }, '', '#settings');
        
        handleHashNavigation();
    }

    function closeSettings() {
        console.log('üéØ Closing settings...');
        
        if (window.location.hash !== '#settings') return;
        
        history.back();
    }

    function handlePopState() {
        console.log('üîô Popstate event');
        setTimeout(handleHashNavigation, 10);
    }

    function setupHashNavigation() {
        console.log('üîß Setting up hash navigation...');
        
        const settingsPanel = document.getElementById('settingsPanel');
        if (!settingsPanel) {
            console.error('‚ùå Settings panel not found!');
            return;
        }
        
        settingsPanel.style.display = 'none';
        
        window.addEventListener('hashchange', handleHashNavigation);
        window.addEventListener('popstate', handlePopState);
        
        setTimeout(() => {
            console.log('üåê Initial hash:', window.location.hash);
            handleHashNavigation();
        }, 100);
        
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && window.location.hash === '#settings') {
                closeSettings();
            }
        });
        
        const settingsBtn = document.getElementById('settingsBtn');
        const backBtn = document.getElementById('backBtn');
        
        if (settingsBtn) {
            settingsBtn.addEventListener('click', openSettings);
        }
        
        if (backBtn) {
            backBtn.addEventListener('click', closeSettings);
        }
        
        console.log('‚úÖ Hash navigation setup complete');
    }

    function toggleChatUI(active) { 
        if (active) { 
            elements.body.classList.add('chat-active'); 
            elements.inputContainer.classList.remove('centered'); 
            elements.inputContainer.classList.add('bottom'); 
            elements.logoContainer.classList.add('logo-hidden'); 
            elements.languageSwitcher.classList.add('lang-hidden'); 
            elements.infoText.style.display = 'block'; 
        } else { 
            elements.body.classList.remove('chat-active'); 
            elements.inputContainer.classList.remove('bottom'); 
            elements.inputContainer.classList.add('centered'); 
            elements.logoContainer.classList.remove('logo-hidden'); 
            elements.languageSwitcher.classList.remove('lang-hidden'); 
            elements.infoText.style.display = 'none'; 
        } 
    }

    function simulateLoading(duration) {
        const splashBar = document.querySelector('.loading-bar');
        
        if (duration === 0) {
            if (elements.splashScreen) {
                elements.splashScreen.style.display = 'none';
                elements.splashScreen.classList.add('hidden');
            }
            return;
        }

        if (!splashBar || !elements.splashScreen) return;

        const startTime = Date.now();
        const intervalId = setInterval(() => {
            const elapsedTime = Date.now() - startTime;
            let progress = (elapsedTime / duration) * 100;

            if (progress >= 100) {
                progress = 100;
                clearInterval(intervalId);
                setTimeout(() => {
                    elements.splashScreen.classList.add('hidden');
                    setTimeout(() => { elements.splashScreen.style.display = 'none'; }, 500);
                }, 500);
            }
            splashBar.style.width = `${progress}%`;
        }, 50);
    }

    function showSuggestions() { 
        const query = elements.questionInput.value.toLowerCase().trim(); 
        elements.suggestionBox.innerHTML = ''; 
        elements.suggestionBox.classList.remove('visible'); 
        if (query.startsWith('/')) { 
            const commandQuery = query.substring(1); 
            const matchingCommands = slashCommands.filter(cmd => cmd.command.substring(1).startsWith(commandQuery)); 
            if (matchingCommands.length > 0) { 
                elements.suggestionBox.classList.add('visible'); 
                matchingCommands.forEach(cmd => { 
                    const div = document.createElement('div'); 
                    div.classList.add('suggestion-item-slash'); 
                    div.innerHTML = `<strong>${cmd.command}</strong><span>${cmd.description}</span>`; 
                    div.addEventListener('click', () => { 
                        elements.questionInput.value = cmd.command + ' '; 
                        elements.suggestionBox.classList.remove('visible'); 
                        elements.questionInput.focus(); 
                    }); 
                    elements.suggestionBox.appendChild(div); 
                }); 
            } 
        } else { 
            if (query.length < 2) return; 
            const suggestions = Object.keys(faqDatabase) 
                .filter(key => key.toLowerCase().includes(query)) 
                .slice(0, 5); 
            if (suggestions.length > 0) { 
                elements.suggestionBox.classList.add('visible'); 
                suggestions.forEach(suggestion => { 
                    const div = document.createElement('div'); 
                    div.classList.add('suggestion-item'); 
                    div.innerText = suggestion; 
                    div.addEventListener('click', () => { 
                        elements.questionInput.value = suggestion; 
                        elements.suggestionBox.classList.remove('visible'); 
                        askAI(); 
                    }); 
                    elements.suggestionBox.appendChild(div); 
                }); 
            } 
        } 
    }

    function findSmartAnswer(question) { 
        const normalized = question.toLowerCase().trim(); 
        const sortedKeys = Object.keys(faqDatabase).sort((a, b) => b.length - a.length); 
        for (const key of sortedKeys) { 
            const normalizedKey = key.toLowerCase().replace("?", ""); 
            if (normalized.includes(normalizedKey)) return faqDatabase[key]; 
        } 
        return null; 
    }

    // PERBAIKAN: Typewriter effect yang tidak menghapus tombol
    function typeWriterEffect(element, text, speed = 0.5) { 
        const parsedHtml = marked.parse(text); 
        const messageContent = element.querySelector('.message-content');
        
        if (!messageContent) {
            console.error('Message content container not found!');
            return Promise.resolve();
        }
        
        let i = 0; 
        messageContent.innerHTML = ''; 
        const tempElement = document.createElement('div'); 
        tempElement.innerHTML = parsedHtml; 
        const textToType = tempElement.innerText; 
        
        return new Promise(resolve => { 
            function type() { 
                if (i < textToType.length) { 
                    messageContent.innerHTML += textToType.charAt(i); 
                    i++; 
                    setTimeout(type, speed); 
                } else { 
                    // When done typing, render the proper Markdown
                    messageContent.innerHTML = parsedHtml; 
                    resolve(); 
                } 
            } 
            type(); 
        }); 
    }

    function stopAI() {
        if (abortController) {
            abortController.abort();
            console.log("Response aborted.");
            
            // Find and complete any active loading animations
            const loadingBubbles = document.querySelectorAll('.ai-loading-container');
            loadingBubbles.forEach(bubble => {
                completeLoading(bubble, false, 'Stopped by user');
                setTimeout(() => {
                    bubble.remove();
                }, 1500);
            });
            
            elements.stopBtn.style.display = 'none';
            elements.sendBtn.style.display = 'block';
            elements.clearBtnContainer.style.display = 'block';
        }

        if (window.speechSynthesis.speaking) {
            window.speechSynthesis.cancel();
            document.querySelectorAll('.speak-btn').forEach(btn => {
                btn.classList.remove('fa-stop');
                btn.classList.add('fa-volume-up');
            });
        }
    }

    // PERBAIKAN: createAiBubble dengan struktur terpisah
    function createAiBubble(text, useInnerHTML = true) {
        const bubble = document.createElement('div');
        bubble.classList.add('chat-bubble', 'ai-bubble', 'fade-in');
        bubble.setAttribute('data-raw-text', text);
        
        // Create separate containers for text and actions
        const messageContent = document.createElement('div');
        messageContent.className = 'message-content';
        
        const messageActions = document.createElement('div');
        messageActions.className = 'message-actions';
        messageActions.innerHTML = `
            <i class="fas fa-copy copy-btn" onclick="copyToClipboard(this)"></i>
            <i class="fas fa-volume-up speak-btn" onclick="speakText(this)"></i>
        `;
        
        if (useInnerHTML) {
            messageContent.innerHTML = marked.parse(text);
        } else {
            // For dynamic API responses, leave empty to be filled by typeWriterEffect
            messageContent.textContent = '';
        }
        
        bubble.appendChild(messageContent);
        bubble.appendChild(messageActions);
        
        return bubble;
    }

    function getLangCodeForSpeech(lang) {
        if (lang === 'en-uk') return 'en-GB';
        if (lang === 'en') return 'en-US';
        if (lang === 'jp') return 'ja-JP';
        if (lang === 'id') return 'id-ID';
        return 'en-US';
    }

    function cleanTextForSpeech(text) {
        if (!text) return '';
        
        let cleaned = text
            .replace(/\*\*(.*?)\*\*/g, '$1')
            .replace(/\*(.*?)\*/g, '$1')
            .replace(/__(.*?)__/g, '$1')
            .replace(/_(.*?)_/g, '$1')
            .replace(/`(.*?)`/g, '$1')
            .replace(/~~(.*?)~~/g, '$1')
            .replace(/==(.*?)==/g, '$1')
            .replace(/\[(.*?)\]\((.*?)\)/g, '$1')
            .replace(/\*/g, '')
            .replace(/#/g, '')
            .replace(/&/g, ' dan ')
            .replace(/@/g, '')
            .replace(/\\n/g, '. ')
            .replace(/\s+/g, ' ')
            .replace(/```[\s\S]*?```/g, '')
            .replace(/<[^>]*>/g, '')
            .replace(/&[a-z]+;/g, '');
        
        cleaned = cleaned.replace(/[^\w\s.,!?;:'"()-]/g, '');
        cleaned = cleaned.trim().replace(/\s+/g, ' ');
        
        return cleaned;
    }

    function speakText(element) {
        const aiBubble = element.closest('.ai-bubble');
        const rawText = aiBubble.getAttribute('data-raw-text');
        const icon = element;

        if (icon.classList.contains('fa-stop')) {
            window.speechSynthesis.cancel();
            return;
        }

        if (window.speechSynthesis.speaking) {
            window.speechSynthesis.cancel();
            document.querySelectorAll('.speak-btn').forEach(btn => {
                btn.classList.remove('fa-stop');
                btn.classList.add('fa-volume-up');
            });
        }

        if (!rawText) return;

        const textToSpeak = cleanTextForSpeech(rawText);
        
        if (!textToSpeak || textToSpeak.trim() === '') {
            console.log('No text to speak after cleaning');
            return;
        }

        const utterance = new SpeechSynthesisUtterance(textToSpeak);
        utterance.lang = getLangCodeForSpeech(currentLanguage);
        utterance.rate = 1.0;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;

        utterance.onstart = () => {
            icon.classList.remove('fa-volume-up');
            icon.classList.add('fa-stop');
        };

        utterance.onend = () => {
            icon.classList.remove('fa-stop');
            icon.classList.add('fa-volume-up');
        };

        utterance.onerror = (event) => {
            console.error('SpeechSynthesis Error:', event.error);
            icon.classList.remove('fa-stop');
            icon.classList.add('fa-volume-up');
        };

        window.speechSynthesis.speak(utterance);
    }

    function copyToClipboard(element) { 
        const aiBubble = element.closest('.ai-bubble'); 
        const textToCopy = aiBubble.getAttribute('data-raw-text'); 
        const formattedText = `${textToCopy}${uiStrings[currentLanguage].copySuffix}`; 
        const tempInput = document.createElement('textarea'); 
        tempInput.value = formattedText; 
        document.body.appendChild(tempInput); 
        tempInput.select(); 
        tempInput.setSelectionRange(0, 99999); 
        document.execCommand('copy'); 
        document.body.removeChild(tempInput); 
        showCopyFeedback(uiStrings[currentLanguage].copyFeedback); 
    }

    function showCopyFeedback(message) { 
        const feedbackDiv = document.createElement('div'); 
        feedbackDiv.innerText = message; 
        feedbackDiv.style.cssText = ` 
            position: fixed; 
            bottom: 150px; 
            left: 50%; 
            transform: translateX(-50%); 
            background-color: #444; 
            color: #fff; 
            padding: 10px 20px; 
            border-radius: 20px; 
            font-size: 14px; 
            z-index: 200; 
            opacity: 0; 
            transition: opacity 0.5s ease-in-out; 
        `; 
        document.body.appendChild(feedbackDiv); 
        setTimeout(() => { feedbackDiv.style.opacity = 1; }, 10); 
        setTimeout(() => { 
            feedbackDiv.style.opacity = 0; 
            setTimeout(() => feedbackDiv.remove(), 500); 
        }, 2000); 
    }

    function checkIndicatorPosition() { 
        const connectionStatus = document.getElementById('connectionStatus'); 
        if (!connectionStatus) return; 
        const indicatorRect = connectionStatus.getBoundingClientRect(); 
        const userBubbles = document.querySelectorAll('.user-bubble'); 
        let isOverlapping = false; 
        for (const bubble of userBubbles) { 
            const bubbleRect = bubble.getBoundingClientRect(); 
            const verticalOverlap = indicatorRect.bottom > bubbleRect.top && indicatorRect.top < bubbleRect.bottom; 
            const horizontalOverlap = indicatorRect.right > bubbleRect.left && indicatorRect.right < bubbleRect.right; 
            if (verticalOverlap && horizontalOverlap) { 
                isOverlapping = true; 
                break; 
            } 
        } 
        connectionStatus.classList.toggle('hidden-by-scroll', isOverlapping); 
    }

    window.debugMirAI = {
        resetApiLimit: () => {
            MEDF_PROCESSOR.resetPublicApiBubbles();
            alert('Public API limit counter has been reset');
            location.reload();
        },
        getApiUsage: () => {
            const count = MEDF_PROCESSOR.countPublicApiBubbles();
            alert(`Public API usage: ${count} bubbles`);
            return count;
        },
        forcePublicApi: () => {
            currentApiKey = DEFAULT_API_KEY;
            isUsingPublicApi = true;
            localStorage.removeItem('miraiApiKey');
            alert('Switched to PUBLIC API for testing');
            location.reload();
        },
        checkApiStatus: () => {
            return {
                isPublic: isUsingPublicApi,
                apiKey: currentApiKey.substring(0, 10) + '...',
                bubbleCount: MEDF_PROCESSOR.countPublicApiBubbles(),
                limits: MEDF_PROCESSOR.PUBLIC_API_LIMITS
            };
        },
        validateMedfFile: async () => {
            try {
                const response = await fetch('config.medf');
                if (!response.ok) throw new Error('config.medf not found');
                
                const buffer = await response.arrayBuffer();
                const code = parseInt(prompt('Enter calculation code:', MEDF_PROCESSOR.DEFAULT_CODE));
                
                const apiKey = await MEDF_PROCESSOR.extractApiKeyFromConfig(buffer, code);
                alert(`‚úÖ File valid!\nAPI Key: ${apiKey.substring(0, 15)}...`);
            } catch (error) {
                alert(`‚ùå Error: ${error.message}`);
            }
        },
        checkSignature: () => {
            const headerText = MEDF_PROCESSOR.HEADER_TEXT;
            const headerCode = MEDF_PROCESSOR.generateHeaderCode(headerText);
            alert(`Header Text: ${headerText}\n\nHeader Code (first 40 chars):\n${headerCode.substring(0, 40)}...\n\nTotal length: ${headerCode.length} digits`);
        },
        // ‚≠ê‚≠ê BARU: Debug untuk search engine
        checkSearchEngineStatus: () => {
            return {
                enabledEngines: getEnabledEnginesCount(),
                searchapi: {
                    enabled: SEARCH_CONFIG.engines.searchapi.enabled,
                    hasApiKey: !!SEARCH_CONFIG.engines.searchapi.apiKey
                },
                google: {
                    enabled: SEARCH_CONFIG.engines.google.enabled,
                    hasApiKey: !!SEARCH_CONFIG.engines.google.apiKey,
                    hasCx: !!SEARCH_CONFIG.engines.google.cx
                },
                duckduckgo: SEARCH_CONFIG.engines.duckduckgo.enabled,
                wikipedia: SEARCH_CONFIG.engines.wikipedia.enabled
            };
        },
        toggleSearchMode: () => {
            const enable = confirm('Enable all search engines? (Cancel to disable all)');
            Object.keys(SEARCH_CONFIG.engines).forEach(engine => {
                SEARCH_CONFIG.engines[engine].enabled = enable;
            });
            saveSearchConfigToLocalStorage();
            loadSearchConfigToUI();
            updateSearchModeInfo();
            alert(`All search engines ${enable ? 'enabled' : 'disabled'}`);
        },
        // Debug untuk memory slider
        checkMemoryStatus: () => {
            return {
                tempMaxBubbles: tempMaxBubbles,
                savedLimit: localStorage.getItem('miraiMaxBubbles'),
                chatHistoryLength: chatHistory.length,
                chatMessages: document.querySelectorAll('.chat-bubble').length
            };
        },
        resetMemoryLimit: () => {
            localStorage.removeItem('miraiMaxBubbles');
            elements.memorySlider.value = '50';
            updateMemorySliderUI('50');
            alert('Memory limit reset to 50');
        }
    };

    document.addEventListener('DOMContentLoaded', () => {
        console.log('üöÄ MirAI Initializing...');
        
        elements = { 
            questionInput: document.getElementById('questionInput'), 
            sendBtn: document.getElementById('sendBtn'), 
            stopBtn: document.getElementById('stopBtn'), 
            clearBtn: document.getElementById('clearBtn'), 
            clearBtnContainer: document.getElementById('clearBtnContainer'), 
            settingsBtn: document.getElementById('settingsBtn'), 
            chatMessages: document.getElementById('chatMessages'), 
            suggestionBox: document.getElementById('suggestionBox'), 
            body: document.body, 
            inputContainer: document.getElementById('inputContainer'), 
            logoContainer: document.querySelector('.logo-container'), 
            splashScreen: document.getElementById('splash-screen'), 
            langDropdown: document.getElementById('langDropdown'), 
            languageSwitcher: document.getElementById('languageSwitcher'), 
            infoText: document.getElementById('infoText'), 
            settingsPanel: document.getElementById('settingsPanel'),
            backBtn: document.getElementById('backBtn'), 
            themeSelect: document.getElementById('themeSelect'), 
            personaSelect: document.getElementById('personaSelect'), 
            customPersonaContainer: document.getElementById('customPersonaContainer'),
            customPersonaInput: document.getElementById('customPersonaInput'),
            customPersonaHint: document.getElementById('customPersonaHint'),
            settingsHeaderTitle: document.getElementById('settingsHeaderTitle'), 
            settingsAppearanceTitle: document.getElementById('settingsAppearanceTitle'), 
            settingsThemeText: document.getElementById('settingsThemeText'), 
            themeLightOption: document.getElementById('themeLightOption'), 
            themeDarkOption: document.getElementById('themeDarkOption'), 
            settingsAITitle: document.getElementById('settingsAITitle'), 
            settingsPersonaText: document.getElementById('settingsPersonaText'), 
            personaFormalOption: document.getElementById('personaFormalOption'), 
            personaDefaultOption: document.getElementById('personaDefaultOption'), 
            personaCreativeOption: document.getElementById('personaCreativeOption'), 
            personaCustomOption: document.getElementById('personaCustomOption'), 
            settingsAboutTitle: document.getElementById('settingsAboutTitle'), 
            settingsVersionText: document.getElementById('settingsVersionText'), 
            settingsAuthorText: document.getElementById('settingsAuthorText'), 
            githubLink: document.getElementById('githubLink'), 
            licenseLink: document.getElementById('licenseLink'), 
            statusDot: document.getElementById('statusDot'), 
            statusLabel: document.getElementById('statusLabel'), 
            apiKeyInput: document.getElementById('apiKeyInput'), 
            toggleApiKey: document.getElementById('toggleApiKey'), 
            saveApiBtn: document.getElementById('saveApiBtn'), 
            settingsApiTitle: document.getElementById('settingsApiTitle'), 
            settingsApiText: document.getElementById('settingsApiText'), 
            toolsBtn: document.getElementById('toolsBtn'), 
            toolsMenu: document.getElementById('toolsMenu'), 
            customConfirmOverlay: document.getElementById('customConfirmOverlay'), 
            customConfirmMessage: document.getElementById('customConfirmMessage'), 
            confirmBtnYes: document.getElementById('confirmBtnYes'), 
            confirmBtnNo: document.getElementById('confirmBtnNo'), 
            helpLink: document.getElementById('helpLink'), 
            termsText: document.getElementById('termsText'),
            exportBtn: document.getElementById('exportBtn'),
            importBtn: document.getElementById('importBtn'),
            importFileInput: document.getElementById('importFileInput'),
            uploadImageBtn: document.getElementById('uploadImageBtn'),
            imageInput: document.getElementById('imageInput'),
            imagePreviewContainer: document.getElementById('imagePreviewContainer'),
            imagePreview: document.getElementById('imagePreview'),
            removeImageBtn: document.getElementById('removeImageBtn'),
            settingsSearchTitle: document.getElementById('settingsSearchTitle'),
            searchConfigDesc: document.getElementById('searchConfigDesc'),
            enableSearchAPI: document.getElementById('enableSearchAPI'),
            searchapiApiKey: document.getElementById('searchapiApiKey'),
            enableGoogleSearch: document.getElementById('enableGoogleSearch'),
            googleApiKey: document.getElementById('googleApiKey'),
            googleCx: document.getElementById('googleCx'),
            enableDuckDuckGo: document.getElementById('enableDuckDuckGo'),
            enableWikipedia: document.getElementById('enableWikipedia'),
            testSearchBtn: document.getElementById('testSearchBtn'),
            clearSearchCacheBtn: document.getElementById('clearSearchCacheBtn'),
            memorySlider: document.getElementById('memorySlider'),
            settingsMemoryTitle: document.getElementById('settingsMemoryTitle'),
            settingsMemoryText: document.getElementById('settingsMemoryText')
        };

        console.log('‚úÖ Elements initialized:', Object.keys(elements).length, 'elements');

        elements.sendBtn.addEventListener('click', askAI);
        elements.stopBtn.addEventListener('click', stopAI);
        elements.clearBtn.addEventListener('click', showClearConfirmation);
        elements.settingsBtn.addEventListener('click', openSettings);
        elements.backBtn.addEventListener('click', closeSettings);
        elements.themeSelect.addEventListener('change', (e) => setTheme(e.target.value));
        elements.personaSelect.addEventListener('change', (e) => setPersona(e.target.value, true));
        elements.langDropdown.addEventListener('change', (event) => setLanguage(event.target.value, true));
        elements.questionInput.addEventListener('keydown', (event) => { 
            if (event.key === 'Enter' && !event.shiftKey) { 
                event.preventDefault(); 
                if (!elements.sendBtn.disabled) { 
                    askAI(); 
                } 
            } 
        });
        elements.questionInput.addEventListener('input', () => { 
            showSuggestions(); 
            updateSendButtonState(); 
            elements.questionInput.style.height = 'auto'; 
            elements.questionInput.style.height = elements.questionInput.scrollHeight + 'px'; 
        });
        elements.saveApiBtn.addEventListener('click', saveApiKey);
        elements.uploadImageBtn.addEventListener('click', () => elements.imageInput.click());
        elements.imageInput.addEventListener('change', handleImageUpload);
        elements.removeImageBtn.addEventListener('click', removeImage);
        elements.toggleApiKey.addEventListener('click', toggleApiVisibility);
        elements.confirmBtnYes.addEventListener('click', () => { 
            clearChat(); 
            hideClearConfirmation();
        });
        elements.confirmBtnNo.addEventListener('click', hideClearConfirmation);
        elements.toolsBtn.addEventListener('click', (event) => { 
            event.stopPropagation(); 
            const isActive = elements.toolsBtn.classList.contains('active'); 
            elements.suggestionBox.classList.remove('visible'); 
            if (!isActive) { 
                elements.toolsMenu.classList.add('visible'); 
                elements.toolsBtn.classList.add('active'); 
            } else { 
                elements.toolsMenu.classList.remove('visible'); 
                elements.toolsBtn.classList.remove('active'); 
            } 
        });
        document.addEventListener('click', (event) => { 
            if (elements.toolsMenu && !elements.toolsMenu.contains(event.target) && !elements.toolsBtn.contains(event.target)) { 
                elements.toolsMenu.classList.remove('visible'); 
                elements.toolsBtn.classList.remove('active'); 
            } 
        });
        window.addEventListener('scroll', checkIndicatorPosition, { passive: true });

        // Memory slider event listener
        elements.memorySlider.addEventListener('input', function() {
            updateMemorySliderUI(this.value);
        });

        elements.exportBtn.addEventListener('click', () => {
            const allData = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                allData[key] = localStorage.getItem(key);
            }
            
            allData._metadata = {
                version: '2.12.0-Beta5',
                persona: currentPersona,
                language: currentLanguage,
                exportDate: new Date().toISOString(),
                model: model,
                format: 'mirai-backup-v2'
            };
            
            const exportType = confirm(
                "Select backup format:\n\n" +
                "[OK] - .medf file (ENCRYPTED with password & authenticity signature)\n" +
                "[CANCEL] - .mdf file (plain JSON)"
            ) ? 'encrypted' : 'plain';
            
            if (exportType === 'encrypted') {
                const password = prompt("Create a password for the encrypted backup:");
                if (!password || password.length < 4) {
                    alert("Password must be at least 4 characters!");
                    return;
                }
                
                processExportMEDF(allData, password)
                    .then(() => alert("‚úÖ .medf backup successfully created with authenticity signature!\nSave your password!"))
                    .catch(err => alert("‚ùå Failed: " + err.message));
                    
            } else {
                const blob = new Blob([JSON.stringify(allData, null, 2)], {type: "application/json"});
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = `MirAIBackup_${formattedDate}.mdf`;
                a.click();
                alert("‚úÖ .mdf backup successfully created!");
            }
        });

        elements.importBtn.addEventListener('click', () => {
            if (chatHistory.length > 2) {
                const confirmImport = confirm(
                    "‚ö†Ô∏è WARNING!\n\n" +
                    "You will import a backup. All current data will be REPLACED.\n\n" +
                    "‚Ä¢ Current chat history will be lost\n" +
                    "‚Ä¢ Settings will be changed according to the backup\n\n" +
                    "Continue?"
                );
                if (!confirmImport) return;
            }
            
            elements.importFileInput.click();
        });

        elements.importFileInput.addEventListener('change', async function(event) {
            console.log('üéØ Import triggered!');
            const file = event.target.files[0];
            if (!file) {
                console.log('‚ùå No file selected');
                return;
            }

            elements.importFileInput.value = '';
            
            console.log('üîÑ Importing file:', {
                name: file.name,
                size: file.size,
                type: file.type
            });
            
            if (file.name.endsWith('.medf')) {
                if (file.size < 50) {
                    alert('‚ùå The file is too small! It may be corrupted.');
                    return;
                }
                
                const password = prompt("üîí Enter the password to open the .medf file:");
                if (!password) {
                    alert('Import canceled.');
                    return;
                }
                
                try {
                    console.time('MEDF Decryption');
                    const data = await processImportMEDF(file, password);
                    console.timeEnd('MEDF Decryption');
                    
                    console.log('‚úÖ MEDF Decrypted:', {
                        keys: Object.keys(data),
                        hasChatHistory: !!data.miraiChatHistory
                    });
                    
                    restoreDataWithPersonaSync(data);
                    
                } catch (err) {
                    console.error('‚ùå MEDF Import Error:', err);
                    alert(`Failed to import .medf file:\n\n${err.message}\n\nMake sure:\n‚Ä¢ Password is correct\n‚Ä¢ File is not corrupted`);
                }
                return;
            }
            
            if (file.name.endsWith('.json') || file.name.endsWith('.mdf')) {
                try {
                    console.time('JSON Parse');
                    const text = await file.text();
                    
                    if (!text || text.trim().length === 0) {
                        alert('‚ùå File kosong!');
                        return;
                    }
                    
                    let data;
                    try {
                        data = JSON.parse(text);
                    } catch (parseError) {
                        alert('‚ùå The file is not a valid JSON format!\n\nMake sure to backup files from MirAI.');
                        return;
                    }
                    
                    console.timeEnd('JSON Parse');
                    console.log('‚úÖ JSON Parsed:', Object.keys(data));
                    
                    restoreDataWithPersonaSync(data);
                    
                } catch (e) { 
                    console.error('‚ùå JSON Import Error:', e);
                    alert(`Gagal import file:\n${e.message}\n\nFile mungkin rusak.`); 
                }
                return;
            }
            
            alert("‚ùå File format not supported!\n\nUse file with extension:\n‚Ä¢ .medf (encrypted backup with authenticity signature)\n‚Ä¢ .mdf (JSON backup)\n‚Ä¢ .json (JSON backup)");
        });

        elements.testSearchBtn.addEventListener('click', testSearch);
        elements.clearSearchCacheBtn.addEventListener('click', () => {
            const enabledCount = getEnabledEnginesCount();
            if (enabledCount === 0) {
                alert('‚ÑπÔ∏è No external search engines enabled. Cache clearing is not needed in AI Knowledge Base mode.');
                return;
            }
            searchCache.clear();
            showCopyFeedback(uiStrings[currentLanguage].searchCacheCleared);
        });

        document.querySelectorAll('.toggle-api-eye').forEach(icon => {
            icon.addEventListener('click', (event) => {
                const targetId = event.target.getAttribute('data-target');
                toggleSearchApiVisibility(targetId);
            });
        });

        setupHashNavigation();

        initializeApp().then(() => {
            console.log('‚úÖ App initialized successfully');
            
            // Initialize memory display
            setTimeout(() => {
                updateMemorySliderUI(elements.memorySlider.value);
            }, 500);
            
            // ‚≠ê‚≠ê BARU: Tampilkan info untuk first-time user
            const isFirstVisit = !localStorage.getItem('miraiSearchConfig');
            if (isFirstVisit && getEnabledEnginesCount() === 0) {
                console.log('üëã Showing first-time search info');
                setTimeout(() => {
                    showCopyFeedback(uiStrings[currentLanguage].firstVisitSearchInfo);
                }, 1000);
            }
            
            if (!isPWA) {
                if (elements.splashScreen) {
                    elements.splashScreen.style.display = 'flex';
                    simulateLoading(3000);
                }
            } else {
                console.log("üì± PWA Mode: Skip splash screen!");
            }

            updateConnectionStatus();
            populateToolsMenu();
            updateSendButtonState();

            window.addEventListener('beforeunload', () => {
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                }
                
                if (window.location.hash === '#settings') {
                    history.replaceState(null, null, ' ');
                }
            });
            
            console.log('üéâ MirAI initialization complete!');
        }).catch(error => {
            console.error('‚ùå Failed to initialize app:', error);
        });
    });

    window.addEventListener('online', updateConnectionStatus);
    window.addEventListener('offline', updateConnectionStatus);
</script>
</body>
</html>