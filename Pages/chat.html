<!DOCTYPE html>

<html lang="id">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>MirAI</title>

    <meta name="description" content="MirAI is a chatbot and personal AI assistant powered by Google Gemini. Get answers, creative ideas, translations, and other help instantly.">

    <meta name="keywords" content="Allwaysever, AI, Artificial Intelligence, Chatbot AI, AI Chatbot, Gemini 2.5 flash, Google Gemini, Gemini API, MirAI">

    <meta name="google-site-verification" content="Ww9spnmeAgguaCwvLVAw-0SV0_ZS-bA7bjNgyWKaeQU"/>

<meta property="og:title" content="MirAI" />
<meta property="og:description" content="MirAI is a chatbot and personal AI assistant powered by Google Gemini. Get answers, creative ideas, translations, and other help instantly." />
<meta property="og:url" content="https://allwaysevermirai.netlify.app/" />
<meta property="og:image" content="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/MirAI%20Banner.png" />

<meta property="og:type" content="article" /> <meta property="og:site_name" content="MirAI by Allwaysever" />

    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <link rel="stylesheet" href="https://esm.sh/gh/Allwaysever/MirAI@main/Assets/CSS/MirAIStyle.css">
   <link rel="manifest" href="https://esm.sh/gh/Allwaysever/MirAI@main/Assets/HTML/MirAIPWAm.json">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<!-- Untuk fullscreen di iOS -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="MirAI">

<!-- Untuk Android/Chrome -->
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1a1a1a">

<!-- Untuk Windows -->
<meta name="msapplication-TileColor" content="#1a1a1a">
<meta name="msapplication-TileImage" content="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">
<meta name="msapplication-config" content="browserconfig.xml">

<!-- Icons untuk berbagai platform -->
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png">
<link rel="mask-icon" href="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Favicon.png" color="#1a1a1a">
<script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>

    <script>
        // notif sw onesignal
  window.OneSignalDeferred = window.OneSignalDeferred || [];
  OneSignalDeferred.push(async function(OneSignal) {
    await OneSignal.init({
      appId: "9b77aea2-462f-498d-be06-bc4f75ab7ab7",
      safari_web_id: "web.onesignal.auto.31f2bfbe-48d0-4a72-b7e0-d44022a2d3bb",
      notifyButton: {
        enable: false,
      },
    });
  });
    
// Di dalam script utama (setelah DOMContentLoaded)
let deferredPrompt;

window.addEventListener('beforeinstallprompt', (e) => {
  // Mencegah tampilan prompt otomatis
  e.preventDefault();
  // Simpan event untuk digunakan nanti
  deferredPrompt = e;
  
  // Tampilkan tombol install custom
  showInstallButton();
});

function showInstallButton() {
  const installBtn = document.createElement('button');
  installBtn.id = 'installBtn';
  installBtn.innerHTML = '<a href="https://allwaysevermirai.netlify.app/download"><i class="fas fa-download"></i> Install App</a>';
  installBtn.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #4285f4;
    color: white;
    text-decoration: none;
    border: none;
    padding: 10px 20px;
    border-radius: 25px;
    cursor: pointer;
    z-index: 1000;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  `;
  
  installBtn.addEventListener('click', async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`User response to the install prompt: ${outcome}`);
      deferredPrompt = null;
      installBtn.remove();
    }
  });
  
  document.body.appendChild(installBtn);
}

// Cek jika app sudah diinstall
window.addEventListener('appinstalled', (evt) => {
  console.log('PWA was installed successfully!');
  // Hapus tombol install jika ada
  const installBtn = document.getElementById('installBtn');
  if (installBtn) installBtn.remove();
});

  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('https://cdn.jsdelivr.net/gh/Allwaysever/MirAI@main/Assets/HTML/MirAIPWAsw.js')
        .then(function(registration) {
          console.log('ServiceWorker registered successfully');
        })
        .catch(function(err) {
          console.log('ServiceWorker registration failed: ', err);
        });
    });
  }
  
// Cek apakah service worker terdaftar
navigator.serviceWorker.getRegistrations().then(registrations => {
  console.log('Registered Service Workers:', registrations);
});

// Atau cek spesifik
if ('serviceWorker' in navigator) {
  console.log('Service Worker supported');
  
  navigator.serviceWorker.ready.then(registration => {
    console.log('Service Worker is ready:', registration);
  });
}

// Auto-generate version based on date
function generateVersion(major, minor, patch) {
    const now = new Date();
    const yymmdd = now.getFullYear().toString().slice(-2) + 
                   String(now.getMonth() + 1).padStart(2, '0') + 
                   String(now.getDate()).padStart(2, '0');
    
    return `${major}.${minor}.${patch}.${yymmdd}`;
} 

// Usage
const VERSION = '2.12.0-Beta5'; // generateVersion(2, 12, 0);
</script>
</head>

<body>
    <div id="splash-screen">

  <div class="splash-content">

    <img src="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Name%20Logo.png" alt="MirAI" class="splash-logo logo-img">

    <div class="loading-bar-container" id="splash-loader">

        <div class="loading-bar"></div>

    </div>
<p style="font-size: 0.5em; color: #aaa; bottom: 5px;">&copy 2025-2026 Allwaysever Project: MirAI</p>
  </div>
</div>



<div id="settingsBtnContainer">

    <button id="settingsBtn">

        <i class="fas fa-bars"></i>

    </button>

</div>

<div id="clearBtnContainer">

    <button id="clearBtn">

        <i class="fas fa-trash-alt"></i>

    </button>

</div>



<div id="connectionStatus">

    <span id="statusDot" class="status-dot"></span>

    <span id="statusLabel" class="status-label"></span>

</div>



<div class="logo-container">

    <img src="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/HI%20new.png" alt="what are we talking about?" class="hi-img">

</div>



<div id="languageSwitcher">

    <select id="langDropdown" class="lang-dropdown">

        <option value="id">üáÆüá© Bahasa Indonesia</option>

        <option value="en">üá∫üá∏ English (US)</option>

        <option value="en-uk">üá¨üáß English (UK)</option>

        <option value="jp">üáØüáµ Êó•Êú¨Ë™û</option>

    </select>

</div>



<div class="chat-container">

    <div id="chatMessages"></div>

</div>





<div id="toolsMenu" class="suggestion-box"></div>



<div id="inputContainer" class="input-container centered">



    <div id="imagePreviewContainer" class="imagePreviewContainer">

       <div class="imagePreviewWrapper">

        <img id="imagePreview" src="" alt="Image Preview" class="imagePreview"">

        <button id="removeImageBtn" class="imgRemoveBtn"><i class="fas fa-times"></i></button>

    </div>

</div>

    

    <div id="suggestionBox" class="suggestion-box"></div>

    <div class="input-box">

        <button id="toolsBtn">

            <i class="fas fa-plus"></i>

        </button>

<button id="uploadImageBtn">

    <i class="fas fa-paperclip"></i>

</button>

<input type="file" id="imageInput" accept="image/*" style="display: none;">

        <textarea id="questionInput" rows="1"></textarea>

        <button id="sendBtn">

            <i class="fas fa-paper-plane"></i>

        </button>

        <button id="stopBtn" style="display: none;">

            <i class="fas fa-stop"></i>

        </button>

    </div>

    <p id="infoText" class="info-text"></p>

</div>



<!-- Settings Panel -->
<div id="settingsPanel">
    <!-- Header -->
    <div class="settings-header">
        <h2 id="settingsHeaderTitle">Pengaturan</h2>
        <button id="backBtn"><i class="fas fa-times"></i></button>
    </div>

    <!-- Body (Scrollable) -->
    <div class="settings-body">
        <div class="settings-content">
            <h3 id="settingsAppearanceTitle">Tampilan</h3>
            <div class="settings-option">
                <p id="settingsThemeText">Pilih preferensi tema Anda:</p>
                <select id="themeSelect">
                    <option value="light" id="themeLightOption">Terang</option>
                    <option value="dark" id="themeDarkOption">Gelap</option>
                </select>
            </div>
            
            <h3 id="settingsAITitle">Persona AI</h3>
            <div class="settings-option">
                <p id="settingsPersonaText">Pilih gaya respons AI:</p>
                <select id="personaSelect">
                    <option value="formal" id="personaFormalOption">Formal & Profesional</option>
                    <option value="default" id="personaDefaultOption">Santai & Bercanda</option>
                    <option value="creative" id="personaCreativeOption">Kreatif & Ekspresif</option>
                    <option value="custom" id="personaCustomOption">Custom Persona</option>
                </select>
                
                <!-- Custom Persona Input -->
                <div id="customPersonaContainer" style="display: none; margin-top: 15px;">
                    <textarea id="customPersonaInput" 
                              class="custom-persona-input" 
                              placeholder="Masukkan prompt custom Anda di sini..."></textarea>
                    <p class="hint-text" id="customPersonaHint">
                        Prompt Anda akan digabungkan dengan: "Anda adalah MirAI, Asisten AI, "
                    </p>
                </div>
            </div>

            <h3 id="settingsApiTitle">Kunci API Google</h3>
            <div class="settings-option">
                <p id="settingsApiText">Masukkan Kunci API kustom Anda:</p>
                <div class="api-key-container">
                    <input type="password" id="apiKeyInput" placeholder="Kosongkan untuk menggunakan kunci default">
                    <i class="fas fa-eye" id="toggleApiKey"></i>
                </div>
            </div>

            <h3 id="settingsBackupTitle">Backup & Restore</h3>
            <div class="settings-option">
                <p style="font-size: 0.8em; color: var(--srui-text-tertiary);" id="backupDescText">Save or move your chat history via JSON file.</p>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button id="exportBtn" class="settings-credits-btn" style="background: var(--srui-success);">
                        <i class="fas fa-download"></i> Export
                    </button>
                    <button id="importBtn" class="settings-credits-btn" style="background: var(--srui-warning); color: var(--srui-accent-text);">
                        <i class="fas fa-upload"></i> Import
                    </button>
                </div>
                <input type="file" id="importFileInput" accept=".json,.mdf,.medf" style="display: none;">
            </div>
            
            <div class="settings-about">
                <h3 id="settingsAboutTitle">Tentang Aplikasi</h3>
                <p id="settingsVersionText"></p>
                <p id="settingsAuthorText">Dikembangkan oleh Allwaysever</p>
                <p><a href="https://allwaysevermirai.netlify.app/about" target="_blank" id="githubLink"><i class="fas fa-info-circle"></i> Tentang MirAI</a></p>
                <p><a href="https://github.com/Allwaysever/MirAI/blob/main/LICENSE" id="licenseLink" target="_blank"><i class="fas fa-file-contract"></i> Lisensi</a></p>
                <p><a href="help/index.html" id="helpLink" target="_self"><i class="fas fa-question-circle"></i> Pusat Bantuan</a></p>
                <div class="gemini-container">
                    <a href="https://deepmind.google/models/gemini/flash/" target="_blank">
                        <img src="https://raw.githubusercontent.com/Allwaysever/MirAI/refs/heads/main/Assets/Gemini%202.5%20Flash%20Logo.png" alt="Google Gemini 2.5 Flash" class="gemini-logo">
                    </a>
                </div>
                <p id="termsText" style="margin-top: 20px; font-size: 0.8em; color: var(--srui-text-secondary);">
                    Dengan menggunakan MirAI, Anda menyetujui <a href="T&C/index.html" target="_blank">Syarat & Ketentuan</a>.
                </p>
            </div>
        </div>
    </div>

    <!-- Footer (Fixed) -->
    <div class="settings-footer">
        <button id="saveApiBtn" class="settings-credits-btn">
            <i class="fas fa-save"></i> Simpan Pengaturan
        </button>
    </div>
</div>

<div id="customConfirmOverlay">

    <div id="customConfirmBox">

        <p id="customConfirmMessage"></p>

        <div class="custom-confirm-buttons">

            <button id="confirmBtnYes"></button>

            <button id="confirmBtnNo"></button>

        </div>

    </div>

</div>

<script>
    const DEFAULT_API_KEY = 'AIzaSyBclOlr7UNm1Leoj83fB9uJR7Jt6qQRphA';

    // === SISTEM API KEY TERENKRIPSI (.medf) dengan Authenticity Header ===
    const MEDF_PROCESSOR = {
        async loadEncryptedApiKey() {
            try {
                // Cek apakah ada config.medf di server
                const response = await fetch('config.medf');
                if (!response.ok) {
                    console.log('config.medf not found, using default');
                    return DEFAULT_API_KEY;
                }
                
                // Baca file
                const buffer = await response.arrayBuffer();
                
                // Kode perhitungan default (bisa disimpan di localStorage)
                const savedCode = localStorage.getItem('miraiConfigCode');
                let code = MEDF_PROCESSOR.DEFAULT_CODE;
                
                if (savedCode) {
                    try {
                        code = parseInt(savedCode);
                    } catch (e) {
                        console.warn('Invalid code, using default');
                    }
                }
                
                // Dekripsi file dengan validasi authenticity
                console.log('üîç Loading and verifying config.medf...');
                const apiKey = await MEDF_PROCESSOR.extractApiKeyFromConfig(buffer, code);
                console.log('‚úÖ API Key berhasil didekripsi dan diverifikasi dari config.medf');
                return apiKey;
                
            } catch (error) {
                console.error('‚ùå Gagal memuat config.medf:', error);
                
                // Tampilkan pesan error yang lebih informatif
                let errorMessage = 'Failed to read config.medf\n\n';
                
                if (error.message.includes('Tidak Otentik') || error.message.includes('signature')) {
                    errorMessage += '‚ö†Ô∏è The config.medf file is not authentic or corrupt!\n';
                    errorMessage += 'The file may have been modified or may not be an official MirAI file.\n\n';
                } else {
                    errorMessage += 'Maybe the calculation code is wrong or the file is corrupted.\n\n';
                }
                
                errorMessage += 'Want to enter manual calculation code?';
                
                if (confirm(errorMessage)) {
                    const userCode = prompt('Enter the calculation code for config.medf:');
                    if (userCode) {
                        try {
                            const code = parseInt(userCode);
                            localStorage.setItem('miraiConfigCode', code);
                            
                            // Coba lagi dengan kode baru
                            const response = await fetch('config.medf');
                            const buffer = await response.arrayBuffer();
                            const apiKey = await MEDF_PROCESSOR.extractApiKeyFromConfig(buffer, code);
                            return apiKey;
                        } catch (e) {
                            console.error('Invalid code:', e);
                        }
                    }
                }
                
                return DEFAULT_API_KEY;
            }
        },
        
        async extractApiKeyFromConfig(fileBuffer, code) {
            // Gunakan fungsi dari processingapi.js jika ada
            if (window.MEDFProcessor && window.MEDFProcessor.extractApiKeyFromConfig) {
                return await window.MEDFProcessor.extractApiKeyFromConfig(fileBuffer, code);
            }
            
            // Fallback dengan validasi authenticity
            try {
                // Generate password dari kode
                const password = this.generatePasswordFromCode(code);
                
                const encoder = new TextEncoder();
                const salt = fileBuffer.slice(0, 16);
                const iv = fileBuffer.slice(16, 28);
                const encryptedData = fileBuffer.slice(28);
                
                console.log('üîê Decrypting with authenticity check...');
                
                // Import key dari password
                const passwordKey = await crypto.subtle.importKey(
                    "raw", 
                    encoder.encode(password), 
                    "PBKDF2", 
                    false, 
                    ["deriveKey"]
                );
                
                // Derive key menggunakan salt
                const key = await crypto.subtle.deriveKey(
                    { 
                        name: "PBKDF2", 
                        salt: salt, 
                        iterations: 100000, 
                        hash: "SHA-256" 
                    },
                    passwordKey, 
                    { name: "AES-GCM", length: 256 }, 
                    false, 
                    ["decrypt"]
                );
                
                // Decrypt data
                const decrypted = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv }, 
                    key, 
                    encryptedData
                );
                
                // Parse JSON hasil decrypt
                const decryptedText = new TextDecoder().decode(decrypted);
                const data = JSON.parse(decryptedText);
                
                // === VALIDASI AUTHENTICITY HEADER ===
                console.log('üîç Validating file authenticity...');
                
                if (!data._signature || !data._signature.headerText || !data._signature.headerCode) {
                    throw new Error("‚ùå The .medf file does not have an authenticity signature!");
                }
                
                // Validasi menggunakan fungsi validateSignature jika ada, atau validasi manual
                let isValid = false;
                
                if (window.MEDFProcessor && window.MEDFProcessor.validateSignature) {
                    isValid = window.MEDFProcessor.validateSignature(
                        data._signature.headerText, 
                        data._signature.headerCode
                    );
                } else {
                    // Validasi manual
                    const HEADER_TEXT = "{MirAI Encrypted Data Files v1.0 By Allwaysever}";
                    
                    if (data._signature.headerText !== HEADER_TEXT) {
                        throw new Error("‚ùå Header text is incorrect!");
                    }
                    
                    // Generate header code untuk validasi
                    let expectedCode = '';
                    for (let i = 0; i < HEADER_TEXT.length; i++) {
                        const charCode = HEADER_TEXT.charCodeAt(i);
                        const transformedCode = (charCode + 2) * 3;
                        expectedCode += transformedCode.toString().padStart(4, '0');
                    }
                    
                    if (data._signature.headerCode !== expectedCode) {
                        throw new Error("‚ùå Header code is incorrect!");
                    }
                    
                    isValid = true;
                }
                
                if (!isValid) {
                    throw new Error("‚ùå .medf File Is Inauthentic or Corrupt!");
                }
                
                console.log('‚úÖ File verified as authentic!');
                
                return data.apiKey || DEFAULT_API_KEY;
                
            } catch (e) {
                console.error('Decryption error:', e);
                
                // Tampilkan pesan error yang lebih spesifik
                if (e.message.includes('Tidak Otentik')) {
                    throw new Error("‚ùå .medf File Is Not Authentic or Corrupt!\nThe file may have been modified or is not an official MirAI file.");
                } else if (e.message.includes('signature')) {
                    throw new Error("‚ùå The file does not have a valid authenticity signature!");
                } else {
                    throw new Error("Incorrect calculation code or corrupted file");
                }
            }
        },
        
        generatePasswordFromCode(code) {
            let num = Math.abs(code);
            let result = '';
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            
            while (num > 0) {
                const remainder = num % 26;
                result = alphabet[remainder] + result;
                num = Math.floor(num / 26);
            }
            
            if (!result) result = 'MIRAI';
            const checksum = code.toString().split('').reduce((a, b) => a + parseInt(b), 0) % 26;
            result += alphabet[checksum];
            
            return result;
        },
        
        // Fungsi untuk mengecek keaslian file backup
        async validateBackupFile(fileBuffer, password) {
            try {
                // Dekripsi file
                const encoder = new TextEncoder();
                const salt = fileBuffer.slice(0, 16);
                const iv = fileBuffer.slice(16, 28);
                const encryptedData = fileBuffer.slice(28);
                
                const passwordKey = await crypto.subtle.importKey(
                    "raw", 
                    encoder.encode(password), 
                    "PBKDF2", 
                    false, 
                    ["deriveKey"]
                );
                
                const key = await crypto.subtle.deriveKey(
                    { 
                        name: "PBKDF2", 
                        salt: salt, 
                        iterations: 100000, 
                        hash: "SHA-256" 
                    },
                    passwordKey, 
                    { name: "AES-GCM", length: 256 }, 
                    false, 
                    ["decrypt"]
                );
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv }, 
                    key, 
                    encryptedData
                );
                
                const decryptedText = new TextDecoder().decode(decrypted);
                const data = JSON.parse(decryptedText);
                
                // Validasi signature
                if (!data._signature) {
                    console.warn('‚ö†Ô∏è Backup file does not have signature');
                    return { isValid: false, message: 'File does not have authenticity signature' };
                }
                
                const HEADER_TEXT = "{MirAI Encrypted Data Files v1.0 By Allwaysever}";
                
                if (data._signature.headerText !== HEADER_TEXT) {
                    return { isValid: false, message: 'Signature header text is invalid' };
                }
                
                // Generate dan validasi header code
                let expectedCode = '';
                for (let i = 0; i < HEADER_TEXT.length; i++) {
                    const charCode = HEADER_TEXT.charCodeAt(i);
                    const transformedCode = (charCode + 2) * 3;
                    expectedCode += transformedCode.toString().padStart(4, '0');
                }
                
                if (data._signature.headerCode !== expectedCode) {
                    return { isValid: false, message: 'Signature header code is invalid' };
                }
                
                return { 
                    isValid: true, 
                    message: '‚úÖ Backup file verified as authentic',
                    data: data 
                };
                
            } catch (error) {
                console.error('Validation error:', error);
                return { 
                    isValid: false, 
                    message: 'Failed to validate file: ' + error.message 
                };
            }
        },
        
        DEFAULT_CODE: 271828,
        HEADER_TEXT: "{MirAI Encrypted Data Files v1.0 By Allwaysever}",
        
        // Fungsi helper untuk generate header code
        generateHeaderCode(text) {
            let code = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                const transformedCode = (charCode + 2) * 3;
                code += transformedCode.toString().padStart(4, '0');
            }
            return code;
        },
        
        countPublicApiBubbles: () => window.MEDFProcessor?.countPublicApiBubbles?.() || 0,
        incrementPublicApiBubbles: () => window.MEDFProcessor?.incrementPublicApiBubbles?.() || 0,
        resetPublicApiBubbles: () => window.MEDFProcessor?.resetPublicApiBubbles?.() || null,
        PUBLIC_API_LIMITS: window.MEDFProcessor?.PUBLIC_API_LIMITS || { MAX_BUBBLES_WARNING: 10, MAX_BUBBLES_BLOCK: 12 }
    };

    let currentApiKey = DEFAULT_API_KEY;
    let isUsingPublicApi = false;

    // [PEMBARUAN] Deteksi model dan mode PWA berdasarkan parameter URL
    const urlParams = new URLSearchParams(window.location.search);
    const isBeta = urlParams.has('betamodel');
    const isPWA = urlParams.has('pwa');
    const model = isBeta ? 'gemini-3-flash-preview' : 'gemini-2.5-flash';
    console.log(`Mode yang aktif: ${isBeta ? 'Beta (3 Flash Preview)' : 'Stable (2.5 Flash)'}`);

    const faqDatabase = {
        "changelog": "# Changelog\n\n Check this project's [github repository](https://github.com/Allwaysever/MirAI/blob/main/CHANGELOG.md) for changelogs information.",
        "donate": "# Donate\n\n Please donate to add features and improve AI capabilities. [Buy us a DiamondStars](https://trakteer.id/Allwaysever)",
        "fullmd": "# Heading 1\n\n## Heading 2\n\n### Heading 3\n\n#### Heading 4\n\n##### Heading 5\n\n###### Heading 6\n\nIni **teks tebal** dan ini *teks miring* dan ini ***teks tebal miring*** dan ~~coret~~.\n\nIni [link](https://example.com) dan ini ![gambar](https://example.com/img.jpg).\n\nIni `kode inline`.\n\n```javascript\nconsole.log('code block');\nfunction test() {\n    return 'hello';\n}\n```\n\n```python\nprint('code block lain')\n```\n\n> Ini blockquote.\n>> Nested blockquote.\n\n- Unordered list item 1\n- Unordered list item 2\n  - Nested item 2.1\n  - Nested item 2.2\n- Unordered list item 3\n\n1. Ordered list item 1\n2. Ordered list item 2\n   1. Nested ordered 2.1\n   2. Nested ordered 2.2\n3. Ordered list item 3\n\n---\n\n***\n\n___\n\n| Tabel Header 1 | Tabel Header 2 | Tabel Header 3 |\n|----------------|----------------|----------------|\n| Cell 1         | Cell 2         | Cell 3         |\n| *Italic*       | **Bold**       | `Code`         |\n\n[^1]: Ini footnote.\n\nIni referensi footnote[^1].\n\n~~Ini coret~~.\n\n**Bold dengan underscore** dan __bold underscore__.\n\n*Italic dengan underscore* dan _italic underscore_.\n\n` ``backtick dalam kode`` `\n\n- [ ] Checklist belum centang\n- [x] Checklist sudah centang\n\n\\*Escape karakter asterisk\\*\n\n\\`Escape backtick\\`\n\nH~2~O (subscript) dan X^2^ (superscript).\n\n==highlight==\n\n:joy: emoji :smile:\n\n<!-- Ini komentar HTML -->\n\n[Link referensi][1]\n\n[1]: https://example.com\n\n```\nplain text code block tanpa bahasa\n```\n\nTerminal:\n\n```bash\n$ npm install\n$ npm start\n```\n\n**Daftar campur:**\n- Item 1\n  1. Sub ordered 1\n  2. Sub ordered 2\n- Item 2\n\n### Tabel kompleks:\n| Left align | Center align | Right align |\n| :--- | :---: | ---: |\n| left | center | right |\n| data | data | data |\n\n**Auto link:** <https://google.com>\n\n**Email:** <email@example.com>\n\n**Horizontal rule dengan asterisk:**\n\n***\n\n**Escape semua:** \\*\\*bold\\*\\* \\*italic\\* \\`code\\`\n\nIni adalah paragraf yang sangat panjang yang harusnya akan membentuk satu paragraf utuh meskipun ditulis dalam beberapa baris dalam kode karena markdown akan menganggapnya sebagai satu paragraf selama tidak ada baris kosong di antaranya. Ini akan terus berlanjut sampai akhir.\n\nDan ini paragraf baru.\n\n    Indented code block dengan spasi.\n\n```mermaid\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n```\n\n$$ \\LaTeX $$ math: $x^2 + y^2 = z^2$\n\n$$\\nblock math\\n$$\n\nColon untuk definition list:\n\nTerm 1\n: Definition 1\n\nTerm 2\n: Definition 2\n\n**Task list lain:**\n- [ ] Task 1\n- [x] Task 2 selesai\n- [ ] Task 3\n\n~~Multiple\nlines\ncoret~~\n\n**Bold\nmultiline**\n\nEnd.",
   };

    const uiStrings = {
        'id': {
            offlineTitle: 'Koneksi Internet Terputus',
            offlineText: 'Silakan periksa koneksi WiFi atau data seluler Anda, lalu coba kembali.',
            retryButton: 'Coba Lagi',
            inputPlaceholder: 'Ketik pertanyaan Anda di sini...',
            copyFeedback: 'Teks berhasil disalin!',
            langSwitchFeedback: 'Bahasa telah diubah ke',
            errorAPI: 'Terjadi kesalahan. Silakan muat ulang atau coba beberapa saat lagi.\n\nHmm... sepertinya kunci API ini telah terkena batas penggunaan. Jika Anda masih menggunakan kunci API bawaan, mohon segera ganti dengan kunci API pribadi Anda. Silakan cek tutorialnya di [Halaman GitHub MirAI](https://github.com/Allwaysever/MirAI?tab=readme-ov-file#%EF%B8%8F-setup-using-your-own-api-key).',
            errorFallback: 'Maaf, jawaban tidak ditemukan. Coba gunakan kata kunci yang berbeda.',
            errorConnection: 'Koneksi internet tidak tersedia. Mohon periksa kembali.',
            checkingConnection: 'Memeriksa koneksi internet...',
            copySuffix: '\n\n-- Dihasilkan oleh MirAI',
            infoText: 'Informasi yang dihasilkan AI mungkin tidak akurat. Verifikasi kembali fakta penting.',
            settingsHeaderTitle: 'Pengaturan',
            settingsAppearanceTitle: 'Tampilan',
            settingsThemeText: 'Pilih preferensi tema Anda:',
            themeLightOption: 'Terang',
            themeDarkOption: 'Gelap',
            settingsAITitle: 'Persona AI',
            settingsPersonaText: 'Pilih gaya respons AI:',
            personaFormalOption: 'Formal & Profesional',
            personaDefaultOption: 'Santai & Bercanda',
            personaCreativeOption: 'Kreatif & Ekspresif',
            personaCustomOption: 'Custom Persona',
            customPersonaHint: 'Prompt Anda akan digabungkan dengan: "Anda adalah MirAI, Asisten AI, "',
            customPersonaPlaceholder: 'Masukkan prompt custom Anda di sini...',
            settingsAboutTitle: 'Tentang Aplikasi',
            settingsVersionText: `Versi: v${VERSION}`,
            settingsAuthorText: 'Dikembangkan oleh Allwaysever',
            githubLink: 'Tentang MirAI',
            licenseLink: 'Lisensi',
            helpLink: 'Pusat Bantuan',
            termsText: 'Dengan menggunakan MirAI, Anda menyetujui <a href="T&C/index.html" target="_blank">Syarat & Ketentuan</a>.',
            personaDefaultPrompt: 'Anda adalah MirAI, asisten AI yang santai dan suka bercanda. Jawab semua pertanyaan dengan gaya yang ramah, sedikit humor, namun tetap informatif.',
            personaFormalPrompt: 'Anda adalah MirAI, asisten AI profesional. Berikan jawaban yang terstruktur, akurat, dan menggunakan bahasa formal.',
            personaCreativePrompt: 'Anda adalah MirAI, asisten AI yang kreatif. Berikan jawaban yang unik, imajinatif, dan ekspresif untuk setiap pertanyaan.',
            personaCustomPrompt: '',
            placeholderMessages: ['Ajukan pertanyaan apa pun.', 'Butuh bantuan untuk ide?', 'Minta terjemahan atau ringkasan.', 'Bagaimana saya bisa membantu?'],
            onlineStatus: 'Terhubung',
            offlineStatus: 'Terputus',
            settingsApiTitle: 'Kunci API Google',
            settingsApiText: 'Masukkan Kunci API kustom Anda:',
            apiKeySaved: 'Kunci API berhasil disimpan.',
            apiKeyRemoved: 'Kunci API dihapus. Menggunakan kunci default.',
            dateTimeContextPrompt: '[{dateTime}]:',
            confirmClearMessage: 'Apakah Anda yakin ingin menghapus riwayat percakapan ini? Tindakan ini tidak dapat diurungkan.',
            confirmClearYes: 'Ya, Hapus',
            confirmClearNo: 'Batal',
            pageTitle: 'MirAI | Asisten AI Anda',
            saveApiKeyBtn: 'Simpan',
            apiKeyPlaceholder: 'Kosongkan untuk menggunakan kunci default',
            settingsBackupTitle: 'Backup & Pulihkan',
            backupDescText: 'Simpan atau pindahkan riwayat chat kamu lewat file JSON.',
            exportBtnText: 'Export',
            importBtnText: 'Import',
            importSuccessText: 'Backup berhasil dipulihkan! Aplikasi akan dimuat ulang.',
            importErrorText: 'Waduh, filenya rusak atau bukan format backup MirAI! üóø',
            installBtnText: 'Install App',
            invalidImageText: 'Silakan unggah file gambar (jpeg, png, webp).',
            betaModelActive: '#3FlashPreviewMode',
            slashCmdSearchTitle: 'Cari',
            slashCmdSearchDesc: '/search [kata kunci pencarian]',
            slashCmdTranslateTitle: 'Terjemahkan',
            slashCmdTranslateDesc: '/translate [teks] to [bahasa]',
            slashCmdSummarizeTitle: 'Ringkas',
            slashCmdSummarizeDesc: '/summarize [teks panjang]',
            slashCmdRephraseTitle: 'Ubah Kalimat',
            slashCmdRephraseDesc: '/rephrase [teks] as [gaya]',
            slashCmdIdeateTitle: 'Buat Ide',
            slashCmdIdeateDesc: '/ideate [jumlah] ideas for [topik]',
            slashCmdFixTitle: 'Perbaiki',
            slashCmdFixDesc: '/fix [teks yang perlu diperbaiki]',
            slashCmdExplainTitle: 'Jelaskan',
            slashCmdExplainDesc: '/explain [konsep] like I\'m [audiens]',
            slashCmdCodeTitle: 'Buat Kode',
            slashCmdCodeDesc: '/code a [bahasa pemrograman] function to [deskripsi]',
            slashErrorInvalidFormat: 'Error: Format tidak valid.',
            slashErrorInvalidFormatTranslate: 'Error: Format tidak valid. Gunakan /translate [teks] to [bahasa]',
            slashErrorInvalidFormatRephrase: 'Error: Format tidak valid. Gunakan /rephrase [teks] as [gaya]',
            slashErrorInvalidFormatIdeate: 'Error: Format tidak valid. Gunakan /ideate [jumlah] ideas for [topik]',
            slashErrorInvalidFormatExplain: 'Error: Format tidak valid. Gunakan /explain [konsep] like I\'m [audiens]',
            slashErrorInvalidFormatCode: 'Error: Format tidak valid. Gunakan /code a [bahasa] function to [deskripsi]',
            slashErrorInvalidFormatSearch: 'Error: Format tidak valid. Gunakan /search [kata kunci]',
            slashErrorUnknownCommand: 'Error: Perintah tidak dikenal.',
            confirmBtnYes: 'Ya, Hapus',
            confirmBtnNo: 'Batal',
            copyFeedback: 'Teks berhasil disalin!',
            pwaInstalledText: 'PWA was installed successfully!',
            apiLimitError: 'Hmm... sepertinya kunci API ini telah terkena batas penggunaan. Jika Anda masih menggunakan kunci API bawaan, mohon segera ganti dengan kunci API pribadi Anda.'
        },
        'en': {
            offlineTitle: 'Internet Connection Lost',
            offlineText: 'Please check your WiFi or cellular data connection, then try again.',
            retryButton: 'Retry',
            inputPlaceholder: 'Type your question here...',
            copyFeedback: 'Text copied to clipboard!',
            langSwitchFeedback: 'Language has been changed to',
            errorAPI: 'An error occurred. Please reload the page or try again shortly.\n\nHmm... it seems that this API key has reached its usage limit. If you are still using the default API key, please replace it with your personal API key immediately. Please check the tutorial on the [MirAI GitHub page](https://github.com/Allwaysever/MirAI?tab=readme-ov-file#%EF%B8%8F-setup-using-your-own-api-key).',
            errorFallback: 'Sorry, no answer was found. Please try different keywords.',
            errorConnection: 'Internet connection is unavailable. Please check and try again.',
            checkingConnection: 'Checking internet connection...',
            copySuffix: '\n\n-- Generated by MirAI',
            infoText: 'AI-generated information may be inaccurate. Please verify important facts.',
            settingsHeaderTitle: 'Settings',
            settingsAppearanceTitle: 'Appearance',
            settingsThemeText: 'Select your theme preference:',
            themeLightOption: 'Light',
            themeDarkOption: 'Dark',
            settingsAITitle: 'AI Persona',
            settingsPersonaText: 'Choose the AI\'s response style:',
            personaFormalOption: 'Formal & Professional',
            personaDefaultOption: 'Chill & joking',
            personaCreativeOption: 'Creative & Expressive',
            personaCustomOption: 'Custom Persona',
            customPersonaHint: 'Your prompt will be combined with: "You are MirAI, an AI Assistant, "',
            customPersonaPlaceholder: 'Enter your custom prompt here...',
            settingsAboutTitle: 'About',
            settingsVersionText: `Version: v${VERSION}`,
            settingsAuthorText: 'Developed by Allwaysever',
            githubLink: 'About MirAI',
            licenseLink: 'License',
            helpLink: 'Help Center',
            termsText: 'By using MirAI, you agree to the <a href="T&C/index.html" target="_blank">Terms & Conditions</a>.',
            personaDefaultPrompt: 'You are MirAI, a relaxed and humorous AI assistant. Answer all questions in a friendly style, with a bit of humor, while remaining informative.',
            personaFormalPrompt: 'You are MirAI, a professional AI assistant. Provide well-structured, accurate, and formal responses.',
            personaCreativePrompt: 'You are MirAI, a creative AI assistant. Provide unique, imaginative, and expressive answers to every query.',
            personaCustomPrompt: '',
            placeholderMessages: ['Ask any question.', 'Need help with an idea?', 'Request a translation or summary.', 'How can I assist you?'],
            onlineStatus: 'Connected',
            offlineStatus: 'Disconnected',
            settingsApiTitle: 'Google API Key',
            settingsApiText: 'Enter your custom API Key:',
            apiKeySaved: 'API Key saved successfully.',
            apiKeyRemoved: 'API Key removed. Using default key.',
            dateTimeContextPrompt: '[{dateTime}]:',
            confirmClearMessage: 'Are you sure you want to delete this chat history? This action cannot be undone.',
            confirmClearYes: 'Yes, Delete',
            confirmClearNo: 'Cancel',
            pageTitle: 'MirAI | Your AI Assistant',
            saveApiKeyBtn: 'Save',
            apiKeyPlaceholder: 'Leave blank to use the default key',
            settingsBackupTitle: 'Backup & Restore',
            backupDescText: 'Save or transfer your chat history via JSON file.',
            exportBtnText: 'Export',
            importBtnText: 'Import',
            importSuccessText: 'Backup restored successfully! App will reload.',
            importErrorText: 'File corrupted or not a MirAI backup! üóø',
            installBtnText: 'Install App',
            invalidImageText: 'Please upload an image file (jpeg, png, webp).',
            betaModelActive: '#3FlashPreviewMode',
            slashCmdSearchTitle: 'Search',
            slashCmdSearchDesc: '/search [search query]',
            slashCmdTranslateTitle: 'Translate',
            slashCmdTranslateDesc: '/translate [text] to [language]',
            slashCmdSummarizeTitle: 'Summarize',
            slashCmdSummarizeDesc: '/summarize [long text]',
            slashCmdRephraseTitle: 'Rephrase',
            slashCmdRephraseDesc: '/rephrase [text] as [tone]',
            slashCmdIdeateTitle: 'Ideate',
            slashCmdIdeateDesc: '/ideate [amount] ideas for [topic]',
            slashCmdFixTitle: 'Fix',
            slashCmdFixDesc: '/fix [text that needs to be corrected]',
            slashCmdExplainTitle: 'Explain',
            slashCmdExplainDesc: '/explain [concept] like I\'m [audience]',
            slashCmdCodeTitle: 'Code',
            slashCmdCodeDesc: '/code a [programming language] function to [description]',
            slashErrorInvalidFormat: 'Error: Invalid format.',
            slashErrorInvalidFormatTranslate: 'Error: Invalid format. Use /translate [text] to [language]',
            slashErrorInvalidFormatRephrase: 'Error: Invalid format. Use /rephrase [text] as [tone]',
            slashErrorInvalidFormatIdeate: 'Error: Invalid format. Use /ideate [number] ideas for [topic]',
            slashErrorInvalidFormatExplain: 'Error: Invalid format. Use /explain [concept] like I\'m [audience]',
            slashErrorInvalidFormatCode: 'Error: Invalid format. Use /code a [language] function to [description]',
            slashErrorInvalidFormatSearch: 'Error: Invalid format. Use /search [query]',
            slashErrorUnknownCommand: 'Error: Unknown command.',
            confirmBtnYes: 'Yes, Delete',
            confirmBtnNo: 'Cancel',
            copyFeedback: 'Text copied to clipboard!',
            pwaInstalledText: 'PWA was installed successfully!',
            apiLimitError: 'Hmm... it seems that this API key has reached its usage limit. If you are still using the default API key, please replace it with your personal API key immediately.'
        },
        'en-uk': {
            offlineTitle: 'Internet Connection Lost',
            offlineText: 'Please check your WiFi or cellular data connection, then try again.',
            retryButton: 'Retry',
            inputPlaceholder: 'Type your question here...',
            copyFeedback: 'Text copied to clipboard!',
            langSwitchFeedback: 'Language has been changed to',
            errorAPI: 'An error occurred. Please reload the page or try again shortly.\n\nHmm... it appears that this API key has reached its usage limit. If you are still using the default API key, please replace it with your personal API key immediately. Please check the tutorial on the [MirAI GitHub page](https://github.com/Allwaysever/MirAI?tab=readme-ov-file#%EF%B8%8F-setup-using-your-own-api-key).',
            errorFallback: 'Sorry, no answer was found. Please try different keywords.',
            errorConnection: 'Internet connection is unavailable. Please check and try again.',
            checkingConnection: 'Checking internet connection...',
            copySuffix: '\n\n-- Generated by MirAI',
            infoText: 'AI-generated information may be inaccurate. Please verify important facts.',
            settingsHeaderTitle: 'Settings',
            settingsAppearanceTitle: 'Appearance',
            settingsThemeText: 'Select your theme preference:',
            themeLightOption: 'Light',
            themeDarkOption: 'Dark',
            settingsAITitle: 'AI Persona',
            settingsPersonaText: 'Choose the AI\'s response style:',
            personaFormalOption: 'Formal & Professional',
            personaDefaultOption: 'Laid-back & bantering',
            personaCreativeOption: 'Creative & Expressive',
            personaCustomOption: 'Custom Persona',
            customPersonaHint: 'Your prompt will be combined with: "You are MirAI, an AI Assistant, "',
            customPersonaPlaceholder: 'Enter your custom prompt here...',
            settingsAboutTitle: 'About',
            settingsVersionText: `Version: v${VERSION}`,
            settingsAuthorText: 'Developed by Allwaysever',
            githubLink: 'About MirAI',
            licenseLink: 'License',
            helpLink: 'Help Center',
            termsText: 'By using MirAI, you agree to the <a href="T&C/index.html" target="_blank">Terms & Conditions</a>.',
            personaDefaultPrompt: 'You are MirAI, a relaxed and humorous AI assistant. Answer all questions in a friendly style, with a bit of humour, while remaining informative.',
            personaFormalPrompt: 'You are MirAI, a professional AI assistant. Provide well-structured, accurate, and formal responses.',
            personaCreativePrompt: 'You are MirAI, a creative AI assistant. Provide unique, imaginative, and expressive answers to every query.',
            personaCustomPrompt: '',
            placeholderMessages: ['Ask any question.', 'Need help with an idea?', 'Request a translation or summary.', 'How can I assist you?'],
            onlineStatus: 'Connected',
            offlineStatus: 'Disconnected',
            settingsApiTitle: 'Google API Key',
            settingsApiText: 'Enter your custom API Key:',
            apiKeySaved: 'API Key saved successfully.',
            apiKeyRemoved: 'API Key removed. Using default key.',
            dateTimeContextPrompt: '[{dateTime}]:',
            confirmClearMessage: 'Are you sure you want to delete this chat history? This action cannot be undone.',
            confirmClearYes: 'Yes, Delete',
            confirmClearNo: 'Cancel',
            pageTitle: 'MirAI | Your AI Assistant',
            saveApiKeyBtn: 'Save',
            apiKeyPlaceholder: 'Leave blank to use the default key',
            settingsBackupTitle: 'Backup & Restore',
            backupDescText: 'Save or transfer your chat history via JSON file.',
            exportBtnText: 'Export',
            importBtnText: 'Import',
            importSuccessText: 'Backup restored successfully! App will reload.',
            importErrorText: 'File corrupted or not a MirAI backup! üóø',
            installBtnText: 'Install App',
            invalidImageText: 'Please upload an image file (jpeg, png, webp).',
            betaModelActive: '#3FlashPreviewMode',
            slashCmdSearchTitle: 'Search',
            slashCmdSearchDesc: '/search [search query]',
            slashCmdTranslateTitle: 'Translate',
            slashCmdTranslateDesc: '/translate [text] to [language]',
            slashCmdSummarizeTitle: 'Summarize',
            slashCmdSummarizeDesc: '/summarize [long text]',
            slashCmdRephraseTitle: 'Rephrase',
            slashCmdRephraseDesc: '/rephrase [text] as [tone]',
            slashCmdIdeateTitle: 'Ideate',
            slashCmdIdeateDesc: '/ideate [amount] ideas for [topic]',
            slashCmdFixTitle: 'Fix',
            slashCmdFixDesc: '/fix [text that needs to be corrected]',
            slashCmdExplainTitle: 'Explain',
            slashCmdExplainDesc: '/explain [concept] like I\'m [audience]',
            slashCmdCodeTitle: 'Code',
            slashCmdCodeDesc: '/code a [programming language] function to [description]',
            slashErrorInvalidFormat: 'Error: Invalid format.',
            slashErrorInvalidFormatTranslate: 'Error: Invalid format. Use /translate [text] to [language]',
            slashErrorInvalidFormatRephrase: 'Error: Invalid format. Use /rephrase [text] as [tone]',
            slashErrorInvalidFormatIdeate: 'Error: Invalid format. Use /ideate [number] ideas for [topic]',
            slashErrorInvalidFormatExplain: 'Error: Invalid format. Use /explain [concept] like I\'m [audience]',
            slashErrorInvalidFormatCode: 'Error: Invalid format. Use /code a [language] function to [description]',
            slashErrorInvalidFormatSearch: 'Error: Invalid format. Use /search [query]',
            slashErrorUnknownCommand: 'Error: Unknown command.',
            confirmBtnYes: 'Yes, Delete',
            confirmBtnNo: 'Cancel',
            copyFeedback: 'Text copied to clipboard!',
            pwaInstalledText: 'PWA was installed successfully!',
            apiLimitError: 'Hmm... it seems that this API key has reached its usage limit. If you are still using the default API key, please replace it with your personal API key immediately.'
        },
        'jp': {
            offlineTitle: '„Ç§„É≥„Çø„Éº„Éç„ÉÉ„ÉàÊé•Á∂ö„Åå„ÅÇ„Çä„Åæ„Åõ„Çì',
            offlineText: 'WiFi„Åæ„Åü„ÅØ„Éá„Éº„ÇøÊé•Á∂ö„ÇíÁ¢∫Ë™ç„Åó„ÄÅÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
            retryButton: 'ÂÜçË©¶Ë°å',
            inputPlaceholder: '„Åì„Åì„Å´Ë≥™Âïè„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ...',
            copyFeedback: '„ÉÜ„Ç≠„Çπ„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü„ÄÇ',
            langSwitchFeedback: 'Ë®ÄË™û„ÅåÂ§âÊõ¥„Åï„Çå„Åæ„Åó„Åü',
            errorAPI: '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åô„Çã„Åã„ÄÅ„Åó„Å∞„Çâ„Åè„Åó„Å¶„Åã„Çâ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ\n\nHmm... „Åì„ÅÆAPI„Ç≠„Éº„ÅØ‰ΩøÁî®Âà∂Èôê„Å´ÈÅî„Åó„Åü„Çà„ÅÜ„Åß„Åô„ÄÇ„Éá„Éï„Ç©„É´„Éà„ÅÆAPI„Ç≠„Éº„Çí„Åæ„Å†‰ΩøÁî®„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åô„Åê„Å´ÂÄã‰∫∫Áî®„ÅÆAPI„Ç≠„Éº„Å´Â§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË©≥Á¥∞„Å™ÊâãÈ†Ü„ÅØ[MirAI„ÅÆGitHub„Éö„Éº„Ç∏](https://github.com/Allwaysever/MirAI?tab=readme-ov-file#%EF%B8%8F-setup-using-your-own-api-key)„ÅÆ„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ',
            errorFallback: 'Áî≥„ÅóË®≥„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÅÂõûÁ≠î„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÂà•„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„Åß„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
            errorConnection: '„Ç§„É≥„Çø„Éº„Éç„ÉÉ„Éà„Å´Êé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÊé•Á∂ö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            checkingConnection: '„Ç§„É≥„Çø„Éº„Éç„ÉÉ„ÉàÊé•Á∂ö„ÇíÁ¢∫Ë™ç‰∏≠...',
            copySuffix: '\n\n-- MirAI„Å´„Çà„Å£„Å¶ÁîüÊàê',
            infoText: 'AI„ÅåÁîüÊàê„Åó„ÅüÊÉÖÂ†±„ÅØ‰∏çÊ≠£Á¢∫„Å™Â†¥Âêà„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÈáçË¶Å„Å™‰∫ãÂÆü„ÅØÂÜçÂ∫¶„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ',
            settingsHeaderTitle: 'Ë®≠ÂÆö',
            settingsAppearanceTitle: 'Â§ñË¶≥',
            settingsThemeText: '„ÉÜ„Éº„Éû„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:',
            themeLightOption: '„É©„Ç§„Éà',
            themeDarkOption: '„ÉÄ„Éº„ÇØ',
            settingsAITitle: 'AI„ÅÆ„Éö„É´„ÇΩ„Éä',
            settingsPersonaText: 'AI„ÅÆÂøúÁ≠î„Çπ„Çø„Ç§„É´„ÇíÈÅ∏Êäû:',
            personaFormalOption: '„Éï„Ç©„Éº„Éû„É´„Éª„Éó„É≠',
            personaDefaultOption: '„ÅÆ„Çì„Å≥„Çä„Åó„Å¶„Å¶ÂÜóË´áÂ•Ω„Åç',
            personaCreativeOption: '„ÇØ„É™„Ç®„Ç§„ÉÜ„Ç£„Éñ„ÉªË°®ÁèæË±ä„Åã',
            personaCustomOption: '„Ç´„Çπ„Çø„É†„Éö„É´„ÇΩ„Éä',
            customPersonaHint: '„Éó„É≠„É≥„Éó„Éà„ÅØ„Äå„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅAI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÅ„Äç„Å®ÁµêÂêà„Åï„Çå„Åæ„Åô',
            customPersonaPlaceholder: '„Ç´„Çπ„Çø„É†„Éó„É≠„É≥„Éó„Éà„Çí„Åì„Åì„Å´ÂÖ•Âäõ...',
            settingsAboutTitle: '„Ç¢„Éó„É™„Å´„Å§„ÅÑ„Å¶',
            settingsVersionText: `„Éê„Éº„Ç∏„Éß„É≥: v${VERSION}`,
            settingsAuthorText: 'ÈñãÁô∫ËÄÖ: Allwaysever',
            githubLink: 'MirAI„Å´„Å§„ÅÑ„Å¶',
            licenseLink: '„É©„Ç§„Çª„É≥„Çπ',
            helpLink: '„Éò„É´„Éó„Çª„É≥„Çø„Éº',
            termsText: 'MirAI„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„Å´„Çà„Çä„ÄÅ<a href="T&C/index.html" target="_blank">Âà©Áî®Ë¶èÁ¥Ñ</a>„Å´ÂêåÊÑè„Åó„Åü„Åì„Å®„Å´„Å™„Çä„Åæ„Åô„ÄÇ',
            personaDefaultPrompt: '„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅ„É™„É©„ÉÉ„ÇØ„Çπ„Åó„Å¶ÂÜóË´áÂ•Ω„Åç„Å™AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ„Éï„É¨„É≥„Éâ„É™„Éº„Å™„Çπ„Çø„Ç§„É´„Åß„ÄÅÂ∞ë„Åó„É¶„Éº„É¢„Ç¢„Çí‰∫§„Åà„Å™„Åå„Çâ„ÇÇ„ÄÅÊÉÖÂ†±„ÇíÊèê‰æõ„Åô„Çã„Çà„ÅÜ„Å´„Åô„Åπ„Å¶„ÅÆË≥™Âïè„Å´Á≠î„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            personaFormalPrompt: '„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅ„Éó„É≠„Éï„Çß„ÉÉ„Ç∑„Éß„Éä„É´„Å™AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇÊßãÈÄ†Âåñ„Åï„Çå„ÄÅÊ≠£Á¢∫„Åß„ÄÅ„Éï„Ç©„Éº„Éû„É´„Å™Ë®ÄËëâÈÅ£„ÅÑ„ÅßÂõûÁ≠î„ÇíÊèê‰æõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            personaCreativePrompt: '„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅÂâµÈÄ†ÁöÑ„Å™AI„Ç¢„Ç∑„Çπ„ÇøNT„Åß„Åô„ÄÇ„Åô„Åπ„Å¶„ÅÆË≥™Âïè„Å´ÂØæ„Åó„Å¶„ÄÅ„É¶„Éã„Éº„ÇØ„ÅßÊÉ≥ÂÉèÂäõ„Å´ÂØå„Çì„Å†Ë°®ÁèæÂäõË±ä„Åã„Å™ÂõûÁ≠î„Çí„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            personaCustomPrompt: '',
            placeholderMessages: ['Ë≥™Âïè„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', '„Ç¢„Ç§„Éá„Ç¢„ÅåÂøÖË¶Å„Åß„Åô„ÅãÔºü', 'ÁøªË®≥„Åæ„Åü„ÅØË¶ÅÁ¥Ñ„Çí‰æùÈ†º„ÄÇ', '‰Ωï„Åã„ÅäÊâã‰ºù„ÅÑ„Åß„Åç„Çã„Åì„Å®„ÅØ„ÅÇ„Çä„Åæ„Åô„ÅãÔºü'],
            onlineStatus: 'Êé•Á∂öÊ∏à„Åø',
            offlineStatus: 'ÂàáÊñ≠',
            settingsApiTitle: 'Google API„Ç≠„Éº',
            settingsApiText: '„Ç´„Çπ„Çø„É†API„Ç≠„Éº„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:',
            apiKeySaved: 'API„Ç≠„Éº„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åó„Åü„ÄÇ',
            apiKeyRemoved: 'API„Ç≠„Éº„ÅåÂâäÈô§„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Éá„Éï„Ç©„É´„Éà„Ç≠„Éº„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ',
            dateTimeContextPrompt: '[{dateTime}]:',
            confirmClearMessage: '„Åì„ÅÆ„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„ÇíÂâäÈô§„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ',
            confirmClearYes: '„ÅØ„ÅÑ„ÄÅÂâäÈô§„Åó„Åæ„Åô',
            confirmClearNo: '„Ç≠„É£„É≥„Çª„É´',
            pageTitle: 'MirAI | AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà',
            saveApiKeyBtn: '‰øùÂ≠ò',
            apiKeyPlaceholder: '„Éá„Éï„Ç©„É´„Éà„Ç≠„Éº„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÅØÁ©∫Ê¨Ñ',
            settingsBackupTitle: '„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Å®Âæ©ÂÖÉ',
            backupDescText: 'JSON„Éï„Ç°„Ç§„É´„Åß„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„Çí‰øùÂ≠ò„Åæ„Åü„ÅØËª¢ÈÄÅ„Åó„Åæ„Åô„ÄÇ',
            exportBtnText: '„Ç®„ÇØ„Çπ„Éù„Éº„Éà',
            importBtnText: '„Ç§„É≥„Éù„Éº„Éà',
            importSuccessText: '„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÅåÊ≠£Â∏∏„Å´Âæ©ÂÖÉ„Åï„Çå„Åæ„Åó„ÅüÔºÅ„Ç¢„Éó„É™„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Åæ„Åô„ÄÇ',
            importErrorText: '„Éï„Ç°„Ç§„É´„ÅåÂ£ä„Çå„Å¶„ÅÑ„Çã„Åã„ÄÅMirAI„ÅÆ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÂΩ¢Âºè„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„ÇìÔºÅüóø',
            installBtnText: '„Ç¢„Éó„É™„Çí„Ç§„É≥„Çπ„Éà„Éº„É´',
            invalidImageText: 'ÁîªÂÉè„Éï„Ç°„Ç§„É´ÔºàJPEG„ÄÅPNG„ÄÅWebPÔºâ„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
            betaModelActive: '#3Flash„Éó„É¨„Éì„É•„Éº„É¢„Éº„Éâ',
            slashCmdSearchTitle: 'Ê§úÁ¥¢',
            slashCmdSearchDesc: '/search [Ê§úÁ¥¢„ÇØ„Ç®„É™]',
            slashCmdTranslateTitle: 'ÁøªË®≥',
            slashCmdTranslateDesc: '/translate [„ÉÜ„Ç≠„Çπ„Éà] to [Ë®ÄË™û]',
            slashCmdSummarizeTitle: 'Ë¶ÅÁ¥Ñ',
            slashCmdSummarizeDesc: '/summarize [Èï∑„ÅÑ„ÉÜ„Ç≠„Çπ„Éà]',
            slashCmdRephraseTitle: 'Ë®Ä„ÅÑÊèõ„Åà',
            slashCmdRephraseDesc: '/rephrase [„ÉÜ„Ç≠„Çπ„Éà] as [Âè£Ë™ø]',
            slashCmdIdeateTitle: '„Ç¢„Ç§„Éá„Ç¢ÁîüÊàê',
            slashCmdIdeateDesc: '/ideate [Êï∞] ideas for [„Éà„Éî„ÉÉ„ÇØ]',
            slashCmdFixTitle: '‰øÆÊ≠£',
            slashCmdFixDesc: '/fix [‰øÆÊ≠£„ÅåÂøÖË¶Å„Å™„ÉÜ„Ç≠„Çπ„Éà]',
            slashCmdExplainTitle: 'Ë™¨Êòé',
            slashCmdExplainDesc: '/explain [Ê¶ÇÂøµ] like I\'m [ÂØæË±°]',
            slashCmdCodeTitle: '„Ç≥„Éº„Éâ',
            slashCmdCodeDesc: '/code a [„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞Ë®ÄË™û] function to [Ë™¨Êòé]',
            slashErrorInvalidFormat: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ',
            slashErrorInvalidFormatTranslate: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /translate [„ÉÜ„Ç≠„Çπ„Éà] to [Ë®ÄË™û] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatRephrase: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /rephrase [„ÉÜ„Ç≠„Çπ„Éà] as [Âè£Ë™ø] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatIdeate: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /ideate [Êï∞] ideas for [„Éà„Éî„ÉÉ„ÇØ] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatExplain: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /explain [Ê¶ÇÂøµ] like I\'m [ÂØæË±°] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatCode: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /code a [Ë®ÄË™û] function to [Ë™¨Êòé] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorInvalidFormatSearch: '„Ç®„É©„Éº: ÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ /search [„ÇØ„Ç®„É™] „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
            slashErrorUnknownCommand: '„Ç®„É©„Éº: ‰∏çÊòé„Å™„Ç≥„Éû„É≥„Éâ„Åß„Åô„ÄÇ',
            confirmBtnYes: '„ÅØ„ÅÑ„ÄÅÂâäÈô§„Åó„Åæ„Åô',
            confirmBtnNo: '„Ç≠„É£„É≥„Çª„É´',
            copyFeedback: '„ÉÜ„Ç≠„Çπ„Éà„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü„ÄÇ',
            pwaInstalledText: 'PWA„ÅåÊ≠£Â∏∏„Å´„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Åæ„Åó„ÅüÔºÅ',
            apiLimitError: '„Åì„ÅÆAPI„Ç≠„Éº„ÅØ‰ΩøÁî®Âà∂Èôê„Å´ÈÅî„Åó„Åü„Çà„ÅÜ„Åß„Åô„ÄÇ„Éá„Éï„Ç©„É´„Éà„ÅÆAPI„Ç≠„Éº„Çí„Åæ„Å†‰ΩøÁî®„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åô„Åê„Å´ÂÄã‰∫∫Áî®„ÅÆAPI„Ç≠„Éº„Å´Â§âÊõ¥„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
        }
    };

    let slashCommands = [];
    let chatHistory = [];
    let abortController = null;
    let currentLanguage = 'en';
    let currentPersona = 'default';
    let currentImageData = null;
    let elements;

    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const formattedDate = `${year}-${month}-${day}_${hours}-${minutes}`;
    console.log(formattedDate);

    // --- LOGIKA UTAMA MIRAI ENCRYPTED DATA FILE (.medf) ---
    const MIRAI_CONFIG = {
        saltLength: 16,
        ivLength: 12,
        iterations: 100000,
        HEADER_TEXT: "{MirAI Encrypted Data Files v1.0 By Allwaysever}"
    };

    async function processExportMEDF(dataJSON, password) {
        // Tambahkan signature authenticity
        const signatureData = {
            _signature: {
                headerText: MIRAI_CONFIG.HEADER_TEXT,
                headerCode: generateHeaderCode(MIRAI_CONFIG.HEADER_TEXT),
                timestamp: new Date().toISOString(),
                version: "1.0"
            },
            ...dataJSON
        };
        
        console.log('üîê Adding authenticity signature for export');
        
        const encoder = new TextEncoder();
        const salt = window.crypto.getRandomValues(new Uint8Array(MIRAI_CONFIG.saltLength));
        const iv = window.crypto.getRandomValues(new Uint8Array(MIRAI_CONFIG.ivLength));

        const passwordKey = await window.crypto.subtle.importKey(
            "raw", encoder.encode(password), "PBKDF2", false, ["deriveKey"]
        );
        const key = await window.crypto.subtle.deriveKey(
            { name: "PBKDF2", salt: salt, iterations: MIRAI_CONFIG.iterations, hash: "SHA-256" },
            passwordKey, { name: "AES-GCM", length: 256 }, false, ["encrypt"]
        );

        const encrypted = await window.crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv }, key, encoder.encode(JSON.stringify(signatureData))
        );

        const finalBlob = new Blob([salt, iv, new Uint8Array(encrypted)], {type: "application/octet-stream"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(finalBlob);
        a.download = `MirAIBackup_ENCRYPTED_${formattedDate}.medf`;
        a.click();
    }

    function generateHeaderCode(text) {
        let code = '';
        for (let i = 0; i < text.length; i++) {
            const charCode = text.charCodeAt(i);
            const transformedCode = (charCode + 2) * 3;
            code += transformedCode.toString().padStart(4, '0');
        }
        return code;
    }

    async function processImportMEDF(file, password) {
      try {
        const buffer = await file.arrayBuffer();
        const uint8View = new Uint8Array(buffer);
        
        const salt = uint8View.slice(0, 16);
        const iv = uint8View.slice(16, 28);
        const encryptedData = uint8View.slice(28);
        
        console.log('MEDF Import Debug:', {
          totalSize: buffer.byteLength,
          saltSize: salt.length,
          ivSize: iv.length,
          dataSize: encryptedData.length
        });
        
        const encoder = new TextEncoder();
        
        const passwordKey = await window.crypto.subtle.importKey(
          "raw", 
          encoder.encode(password), 
          "PBKDF2", 
          false, 
          ["deriveKey"]
        );
        
        const key = await window.crypto.subtle.deriveKey(
          { 
            name: "PBKDF2", 
            salt: salt, 
            iterations: MIRAI_CONFIG.iterations, 
            hash: "SHA-256" 
          },
          passwordKey, 
          { name: "AES-GCM", length: 256 }, 
          false, 
          ["decrypt"]
        );
        
        const decrypted = await window.crypto.subtle.decrypt(
          { name: "AES-GCM", iv: iv }, 
          key, 
          encryptedData
        );
        
        const decryptedText = new TextDecoder().decode(decrypted);
        const data = JSON.parse(decryptedText);
        
        // === VALIDASI AUTHENTICITY ===
        console.log('üîç Validating backup authenticity...');
        
        if (!data._signature) {
          console.warn('‚ö†Ô∏è Backup file does not have signature');
          alert('‚ö†Ô∏è Warning: Backup file does not have authenticity signature.\nFile may not be from official MirAI.');
          // Lanjutkan tapi dengan warning
        } else {
          // Validasi signature
          const HEADER_TEXT = MIRAI_CONFIG.HEADER_TEXT;
          
          if (data._signature.headerText !== HEADER_TEXT) {
            throw new Error("‚ùå Backup file tidak otentik! Header text tidak sesuai.");
          }
          
          // Generate expected code
          let expectedCode = '';
          for (let i = 0; i < HEADER_TEXT.length; i++) {
            const charCode = HEADER_TEXT.charCodeAt(i);
            const transformedCode = (charCode + 2) * 3;
            expectedCode += transformedCode.toString().padStart(4, '0');
          }
          
          if (data._signature.headerCode !== expectedCode) {
            throw new Error("‚ùå Backup file is not authentic! Header code does not match.");
          }
          
          console.log('‚úÖ Backup file verified as authentic');
        }
        
        return data;
        
      } catch (e) {
        console.error('MEDF Import Error:', e);
        
        // Pesan error yang lebih informatif
        if (e.message.includes('tidak otentik')) {
          throw new Error("‚ùå The backup file is not authentic or has been modified!\n\n" +
                         "Files may be:\n" +
                         "‚Ä¢ Not an official backup of MirAI\n" +
                         "‚Ä¢ Has been modified by another party\n" +
                         "‚Ä¢ Experiencing data corruption\n\n" +
                         "Use the original backup file from MirAI.");
        } else {
          throw new Error("Wrong password or corrupted .medf file!");
        }
      }
    }

    // --- FUNGSI BACKUP & RESTORE ---
    function normalizeBackupData(data) {
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) {
          return null;
        }
      }
      
      if (Array.isArray(data)) {
        return {
          miraiChatHistory: JSON.stringify(data),
          _metadata: {
            version: 'legacy',
            persona: 'default',
            exportDate: new Date().toISOString()
          }
        };
      }
      
      if (data && typeof data === 'object' && !data._metadata) {
        if (Array.isArray(data.chatHistory) || Array.isArray(data.history)) {
          const chatArray = data.chatHistory || data.history || [];
          return {
            miraiChatHistory: JSON.stringify(chatArray),
            miraiPersona: data.persona || 'default',
            miraiLanguage: data.language || 'en',
            _metadata: {
              version: data.version || 'legacy-v2',
              persona: data.persona || 'default',
              exportDate: new Date().toISOString()
            }
          };
        }
        
        return {
          ...data,
          _metadata: {
            version: 'localStorage-format',
            exportDate: new Date().toISOString()
          }
        };
      }
      
      return data;
    }

    function restoreDataWithPersonaSync(originalData) {
      const data = normalizeBackupData(originalData);
      
      if (!data) {
        alert('‚ùå The backup file is invalid or corrupted!');
        return;
      }
      
      const metadata = data._metadata || {};
      const backupPersona = metadata.persona || data.miraiPersona || 'default';
      const backupLanguage = metadata.language || currentLanguage;
      
      // Cek apakah file memiliki signature keaslian
      const hasSignature = data._signature && 
                          data._signature.headerText && 
                          data._signature.headerCode;
      
      let verificationStatus = '';
      if (hasSignature) {
        const HEADER_TEXT = MIRAI_CONFIG.HEADER_TEXT;
        
        // Validasi sederhana
        if (data._signature.headerText === HEADER_TEXT) {
          verificationStatus = '‚úÖ VERIFIED - Authentic files from MirAI';
        } else {
          verificationStatus = '‚ö†Ô∏è WARNING - Invalid signature';
        }
      } else {
        verificationStatus = '‚ö†Ô∏è WARNING - File does not have authenticity signature';
      }
      
      console.log('Restoring backup:', {
        persona: backupPersona,
        language: backupLanguage,
        metadata: metadata,
        hasSignature: hasSignature,
        verificationStatus: verificationStatus
      });
      
      // Tampilkan status verifikasi kepada user
      const dataToStore = { ...data };
      delete dataToStore._metadata;
      delete dataToStore._signature; // Hapus signature sebelum disimpan
      
      localStorage.clear();
      
      Object.keys(dataToStore).forEach(key => {
        if (key && dataToStore[key] !== null && dataToStore[key] !== undefined) {
          localStorage.setItem(key, dataToStore[key]);
        }
      });
      
      const restoredHistory = localStorage.getItem('miraiChatHistory');
      
      if (restoredHistory) {
        try {
          let chatHistory = JSON.parse(restoredHistory);
          
          chatHistory = chatHistory.filter(item => {
            if (item.parts && item.parts[0] && item.parts[0].text) {
              const text = item.parts[0].text.toLowerCase();
              const isPersonaPrompt = 
                text.includes('you are mirai') ||
                text.includes('system instruction') ||
                text.includes('[persona:') ||
                text.includes('personality');
              return !isPersonaPrompt;
            }
            return true;
          });
          
          const lang = backupLanguage || localStorage.getItem('miraiLanguage') || 'en';
          const personaPromptText = getPersonaPrompt(backupPersona);
          
          if (personaPromptText) {
            chatHistory.unshift({ 
              role: "user", 
              parts: [{ 
                text: `[PERSONA: ${backupPersona.toUpperCase()}]\n${personaPromptText}` 
              }] 
            });
            
            console.log('‚úÖ Added persona prompt:', backupPersona);
          }
          
          localStorage.setItem('miraiChatHistory', JSON.stringify(chatHistory));
          
        } catch (e) {
          console.error('Error during persona sync:', e);
        }
      }
      
      if (backupPersona) localStorage.setItem('miraiPersona', backupPersona);
      if (backupLanguage && uiStrings[backupLanguage]) {
        localStorage.setItem('miraiLanguage', backupLanguage);
      }
      
      const restoredChats = restoredHistory ? JSON.parse(restoredHistory).length : 0;
      const successMsg = `‚úÖ BACKUP RESTORED SUCCESSFUL!\n\n` +
                        `‚Ä¢ Persona: ${backupPersona}\n` +
                        `‚Ä¢ Language: ${backupLanguage}\n` +
                        `‚Ä¢ Chat: ${restoredChats} messages\n` +
                        `‚Ä¢ Verification: ${verificationStatus}\n\n` +
                        `App will be reloading...`;
      
      alert(successMsg);
      
      setTimeout(() => {
        console.log('Reloading application after restore...');
        location.reload();
      }, 800);
    }

    // === FUNGSI LIMIT API PUBLIK ===
    function isPublicApiKey(apiKey) {
        return apiKey === DEFAULT_API_KEY;
    }

    function showApiLimitPopup(level, bubbleCount) {
        const lang = uiStrings[currentLanguage];
        
        let message, showSettingsBtn = false;
        
        if (level === 'warning') {
            message = `‚ö†Ô∏è PUBLIC FIRE LIMIT WARNING\n\n` +
                     `You have used ${bubbleCount} bubbles with public API Key.\n` +
                     `The maximum limit is ${MEDF_PROCESSOR.PUBLIC_API_LIMITS.MAX_BUBBLES_WARNING} bubbles.\n\n` +
                     `To continue unlimited chat, please use your personal API Key.`;
        } else if (level === 'block') {
            message = `üö´ PUBLIC API BLOCKED\n\n` +
                     `You have reached the limit ${bubbleCount} bubbles with public API Key.\n` +
                     `Access to the public API is now disabled.\n\n` +
                     `To continue using MirAI, please enter your personal API Key.`;
            showSettingsBtn = true;
        }
        
        const popupOverlay = document.createElement('div');
        popupOverlay.id = 'apiLimitPopup';
        popupOverlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            animation: fadeIn 0.3s ease;
        `;
        
        const popupContent = document.createElement('div');
        popupContent.style.cssText = `
            background: var(--srui-bg-primary, #1a1a1a);
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 2px solid ${level === 'warning' ? '#ff9800' : '#f44336'};
        `;
        
        const messageEl = document.createElement('p');
        messageEl.style.cssText = `
            color: var(--srui-text-primary, #fff);
            margin-bottom: 20px;
            line-height: 1.5;
            white-space: pre-line;
        `;
        messageEl.textContent = message;
        
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        `;
        
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.cssText = `
            background: #666;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        `;
        closeBtn.onclick = () => {
            document.body.removeChild(popupOverlay);
        };
        
        popupContent.appendChild(messageEl);
        
        if (showSettingsBtn) {
            const settingsBtn = document.createElement('button');
            settingsBtn.textContent = 'Install My API Key';
            settingsBtn.style.cssText = `
                background: #4285f4;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                font-weight: bold;
                display: flex;
                align-items: center;
                gap: 8px;
                margin: 10px auto;
            `;
            settingsBtn.onclick = () => {
                document.body.removeChild(popupOverlay);
                if (window.location.hash !== '#settings') {
                    history.pushState({ settings: true }, '', '#settings');
                    setTimeout(handleHashNavigation, 50);
                }
            };
            popupContent.appendChild(settingsBtn);
        }
        
        popupContent.appendChild(buttonContainer);
        buttonContainer.appendChild(closeBtn);
        popupOverlay.appendChild(popupContent);
        
        document.body.appendChild(popupOverlay);
    }

    function checkAndUpdatePublicApiLimit() {
        if (!isUsingPublicApi) return true;
        
        const bubbleCount = MEDF_PROCESSOR.countPublicApiBubbles();
        
        if (bubbleCount === MEDF_PROCESSOR.PUBLIC_API_LIMITS.MAX_BUBBLES_WARNING) {
            console.log('‚ö†Ô∏è Public API warning limit reached');
            setTimeout(() => {
                showApiLimitPopup('warning', bubbleCount);
            }, 1000);
        }
        
        if (bubbleCount >= MEDF_PROCESSOR.PUBLIC_API_LIMITS.MAX_BUBBLES_BLOCK) {
            console.log('üö´ Public API blocked - maximum limit reached');
            setTimeout(() => {
                showApiLimitPopup('block', bubbleCount);
            }, 1000);
            return false;
        }
        
        return true;
    }

    function trackPublicApiUsage() {
        if (isUsingPublicApi) {
            const newCount = MEDF_PROCESSOR.incrementPublicApiBubbles();
            console.log(`üìà Public API bubble count: ${newCount}`);
        }
    }

    // --- FUNGSI UTAMA MIRAI ---
    function initializeSlashCommands(lang) {
        const s = uiStrings[lang];
        slashCommands = [
            { command: '/search', title: s.slashCmdSearchTitle, description: '/search [search query]' },
            { command: '/translate', title: s.slashCmdTranslateTitle, description: '/translate [text] to [language]' },
            { command: '/summarize', title: s.slashCmdSummarizeTitle, description: '/summarize [long text]' },
            { command: '/rephrase', title: s.slashCmdRephraseTitle, description: '/rephrase [text] as [tone]' },
            { command: '/ideate', title: s.slashCmdIdeateTitle, description: '/ideate [amount] ideas for [topic]' },
            { command: '/fix', title: s.slashCmdFixTitle, description: '/fix [text that needs to be corrected]' },
            { command: '/explain', title: s.slashCmdExplainTitle, description: '/explain [concept] like I\'m [audience]' },
            { command: '/code', title: s.slashCmdCodeTitle, description: '/code a [programming language] function to [description]' }
        ];
    }

    function convertImageToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => {
                const base64String = reader.result.split(',')[1];
                resolve(base64String);
            };
            reader.onerror = error => reject(error);
        });
    }

    function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        if (!file.type.startsWith('image/')) {
            alert(uiStrings[currentLanguage].invalidImageText);
            return;
        }

        elements.imageInput.value = '';

        convertImageToBase64(file)
            .then(base64Data => {
                currentImageData = {
                    mimeType: file.type,
                    data: base64Data
                };
                
                elements.imagePreview.src = `data:${file.type};base64,${base64Data}`;
                elements.imagePreviewContainer.style.display = 'flex';
                toggleChatUI(true);
                updateSendButtonState();
            })
            .catch(error => {
                console.error('Error converting image:', error);
                removeImage();
            });
    }

    function removeImage() {
        currentImageData = null;
        elements.imagePreview.src = '';
        elements.imagePreviewContainer.style.display = 'none';
        elements.imageInput.value = '';
        updateSendButtonState();
    }

    // Fungsi untuk mendapatkan prompt persona berdasarkan tipe
    function getPersonaPrompt(personaType) {
        if (personaType === 'custom') {
            const customText = localStorage.getItem('miraiCustomPersona') || '';
            // Gabungkan dengan prefix default
            const lang = uiStrings[currentLanguage];
            if (currentLanguage === 'id') {
                return `Anda adalah MirAI, Asisten AI, ${customText}`;
            } else if (currentLanguage === 'jp') {
                return `„ÅÇ„Å™„Åü„ÅØMirAI„ÄÅAI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÅ${customText}`;
            } else {
                return `You are MirAI, an AI Assistant, ${customText}`;
            }
        }
        
        const promptKey = `persona${personaType.charAt(0).toUpperCase() + personaType.slice(1)}Prompt`;
        return uiStrings[currentLanguage][promptKey] || uiStrings['en'][promptKey];
    }

    async function initializeApp() {
        console.log('üîß Initializing app...');
        
        // Load API Key dari config.medf TERLEBIH DAHULU
        try {
            currentApiKey = await MEDF_PROCESSOR.loadEncryptedApiKey();
            console.log('üîë API Key loaded from config.medf:', currentApiKey.substring(0, 10) + '...');
        } catch (error) {
            console.error('Failed to load API key from config.medf:', error);
            currentApiKey = DEFAULT_API_KEY;
        }
        
        // Tentukan apakah menggunakan API publik
        isUsingPublicApi = isPublicApiKey(currentApiKey);
        console.log(`üåê Using ${isUsingPublicApi ? 'PUBLIC' : 'PRIVATE'} API Key`);
        
        if (isUsingPublicApi) {
            const bubbleCount = MEDF_PROCESSOR.countPublicApiBubbles();
            console.log(`üìä Public API usage: ${bubbleCount} bubbles used`);
            
            if (bubbleCount >= MEDF_PROCESSOR.PUBLIC_API_LIMITS.MAX_BUBBLES_WARNING) {
                setTimeout(() => {
                    showApiLimitPopup('warning', bubbleCount);
                }, 2000);
            }
        }
        
        const savedLang = localStorage.getItem('miraiLanguage');
        if (savedLang && uiStrings.hasOwnProperty(savedLang)) {
            currentLanguage = savedLang;
        } else {
            currentLanguage = 'en';
        }

        currentPersona = localStorage.getItem('miraiPersona') || 'default';
        const savedTheme = localStorage.getItem('miraiTheme') || 'dark';
        const savedApiKey = localStorage.getItem('miraiApiKey');
        
        elements.langDropdown.value = currentLanguage;
        elements.personaSelect.value = currentPersona;
        
        if (savedApiKey) {
            currentApiKey = savedApiKey;
            elements.apiKeyInput.value = savedApiKey;
            console.log('üîë Using API Key from localStorage');
            isUsingPublicApi = isPublicApiKey(currentApiKey);
        }

        // Load custom persona jika ada
        const savedCustomPersona = localStorage.getItem('miraiCustomPersona');
        if (savedCustomPersona) {
            currentPersona = 'custom';
            elements.personaSelect.value = 'custom';
            elements.customPersonaContainer.style.display = 'block';
            elements.customPersonaInput.value = savedCustomPersona;
        }

        initializeSlashCommands(currentLanguage);
        setTheme(savedTheme);
        updateUI();
        
        const historyLoaded = loadChatHistory();
        if (!historyLoaded) {
            initializeNewChatSession();
        }
        
        if (isBeta) {
            const versionText = document.getElementById('settingsVersionText');
            if (versionText) {
                versionText.innerText += '\n3FlashPreviewMode';
                versionText.style.color = '#00ff00';
            }
        }
    }

    function initializeNewChatSession() {
        const personaPromptText = getPersonaPrompt(currentPersona);
        chatHistory = [{ role: "user", parts: [{ text: personaPromptText }] }];
        console.log('Sesi chat baru dimulai dengan persona:', currentPersona);
    }

    function loadChatHistory() {
        const savedHistory = localStorage.getItem('miraiChatHistory');
        if (savedHistory) {
            chatHistory = JSON.parse(savedHistory);
            console.log('Riwayat percakapan berhasil dimuat.', chatHistory);
            return true;
        }
        console.log('Tidak ada riwayat untuk dimuat.');
        return false;
    }

    function saveChatHistory() {
        const maxHistoryLength = 50;
        if (chatHistory.length > maxHistoryLength) {
            const personaPrompt = chatHistory[0];
            const conversation = chatHistory.slice(chatHistory.length - maxHistoryLength + 1);
            chatHistory = [personaPrompt, ...conversation];
        }
        localStorage.setItem('miraiChatHistory', JSON.stringify(chatHistory));
    }

    function clearChat() {
        elements.chatMessages.innerHTML = '';
        localStorage.removeItem('miraiChatHistory');
        initializeNewChatSession();
        toggleChatUI(false);
        updateDynamicPlaceholder();
        
        if (window.speechSynthesis.speaking) {
            window.speechSynthesis.cancel();
        }
    }

    function showClearConfirmation() {
        const lang = uiStrings[currentLanguage];
        elements.customConfirmMessage.innerText = lang.confirmClearMessage;
        elements.confirmBtnYes.innerText = lang.confirmClearYes;
        elements.confirmBtnNo.innerText = lang.confirmClearNo;
        elements.customConfirmOverlay.classList.add('visible');
    }

    function hideClearConfirmation() {
        elements.customConfirmOverlay.classList.remove('visible');
    }

    function setPersona(persona, fromUserInteraction = false) {
        currentPersona = persona;
        elements.personaSelect.value = persona;
        localStorage.setItem('miraiPersona', persona);
        
        // Tampilkan atau sembunyikan custom persona input
        if (persona === 'custom') {
            elements.customPersonaContainer.style.display = 'block';
            const savedCustomPrompt = localStorage.getItem('miraiCustomPersona');
            if (savedCustomPrompt) {
                elements.customPersonaInput.value = savedCustomPrompt;
            }
        } else {
            elements.customPersonaContainer.style.display = 'none';
        }
        
        // Update chat history dengan persona yang dipilih
        if (chatHistory.length > 0 && chatHistory[0].role === "user") {
            const personaPromptText = getPersonaPrompt(persona);
            chatHistory[0].parts[0].text = personaPromptText;
            saveChatHistory();
        }
    }

    function setLanguage(lang, fromUserInteraction = false) {
        currentLanguage = lang;
        elements.langDropdown.value = lang;
        localStorage.setItem('miraiLanguage', lang);
        initializeSlashCommands(currentLanguage);
        populateToolsMenu();
        updateUI();
    }

    async function askAI() {
        const userQuestion = elements.questionInput.value;

        if (userQuestion.trim() === '' && !currentImageData) return;

        // CEK LIMIT API PUBLIK SEBELUM MENGIRIM
        if (isUsingPublicApi && !checkAndUpdatePublicApiLimit()) {
            toggleChatUI(false);
            elements.sendBtn.style.display = 'block';
            elements.stopBtn.style.display = 'none';
            elements.clearBtnContainer.style.display = 'block';
            return;
        }

        const clientDateTime = getCurrentDateTimeString();
        const promptTemplate = uiStrings[currentLanguage].dateTimeContextPrompt;
        const contextPrompt = promptTemplate.replace('{dateTime}', clientDateTime);
        
        let promptToSendToAI;

        if (!currentImageData) {
            const processedPrompt = handleSlashCommand(userQuestion);
            if (processedPrompt !== null) {
                if (processedPrompt.startsWith('Error:')) {
                    return;
                }
                promptToSendToAI = `${contextPrompt}\n\n"${processedPrompt}"`;
            } else {
                promptToSendToAI = `${contextPrompt}\n\n"${userQuestion}"`;
            }
        } else {
            promptToSendToAI = `${contextPrompt}\n\n"${userQuestion}"`;
        }

        toggleChatUI(true);
        elements.questionInput.value = '';
        elements.questionInput.style.height = 'auto';
        elements.suggestionBox.classList.remove('visible');
        updateSendButtonState();
        elements.sendBtn.style.display = 'none';
        elements.clearBtnContainer.style.display = 'none';
        elements.stopBtn.style.display = 'block';

        const userBubble = document.createElement('div');
        userBubble.classList.add('chat-bubble', 'user-bubble');
        
        let userBubbleHTML = '';
        if (currentImageData) {
            userBubbleHTML += `<img src="${elements.imagePreview.src}" style="width: 100%; max-width: 200px; border-radius: 10px; margin-bottom: 5px;"><br>`;
        }
        
        const textNode = document.createTextNode(userQuestion);
        userBubble.appendChild(textNode);
        
        if(currentImageData) {
            userBubble.innerHTML = userBubbleHTML;
            userBubble.appendChild(document.createElement('br'));
            userBubble.appendChild(textNode);
        }

        elements.chatMessages.appendChild(userBubble);
        setTimeout(() => userBubble.classList.add('fade-in'), 10);
        elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;

        const userParts = [];
        userParts.push({ text: promptToSendToAI });

        if (currentImageData) {
            userParts.push({
                inlineData: {
                    mimeType: currentImageData.mimeType,
                    data: currentImageData.data
                }
            });
        }
        
        chatHistory.push({ role: "user", parts: userParts });
        saveChatHistory();
        
        const imageWasSent = !!currentImageData;
        removeImage();

        const loadingBubble = showLoading();

        if (!imageWasSent) {
            const localAnswer = findSmartAnswer(userQuestion);
            if (localAnswer) {
                loadingBubble.remove();
                const aiBubble = createAiBubble(localAnswer, true);
                elements.chatMessages.appendChild(aiBubble);
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
                elements.sendBtn.style.display = 'block';
                elements.stopBtn.style.display = 'none';
                elements.clearBtnContainer.style.display = 'block';
                return;
            }
        }

        try {
            abortController = new AbortController();
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${currentApiKey}`;
            
            const requestBody = { contents: chatHistory };

            const response = await fetch(url, { 
                method: "POST", 
                headers: { "Content-Type": "application/json" }, 
                body: JSON.stringify(requestBody), 
                signal: abortController.signal 
            });
            
            if (!response.ok) { 
                throw new Error(`HTTP error! status: ${response.status}`); 
            }
            
            const data = await response.json();
            let answer = uiStrings[currentLanguage].errorFallback;
            
            if (data.candidates?.[0]?.content?.parts?.[0]) {
                answer = data.candidates[0].content.parts[0].text;
                chatHistory.push({ role: "model", parts: [{ text: answer }] });
                saveChatHistory();
                
                // JIKA BERHASIL, TRACK USAGE
                if (isUsingPublicApi) {
                    trackPublicApiUsage();
                }
            }
            
            loadingBubble.remove();
            const aiBubble = createAiBubble(answer, false);
            elements.chatMessages.appendChild(aiBubble);
            await typeWriterEffect(aiBubble, answer);
            
            const copyBtn = document.createElement('i');
            copyBtn.classList.add('fas', 'fa-copy', 'copy-btn');
            copyBtn.setAttribute('onclick', 'copyToClipboard(this)');
            aiBubble.appendChild(copyBtn);

            const speakBtn = document.createElement('i');
            speakBtn.classList.add('fas', 'fa-volume-up', 'speak-btn');
            speakBtn.setAttribute('onclick', 'speakText(this)');
            aiBubble.appendChild(speakBtn);

            elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
        } catch (error) {
            console.error('Error:', error);
            if (error.name !== 'AbortError') {
                const errorMessage = navigator.onLine ? uiStrings[currentLanguage].errorAPI : uiStrings[currentLanguage].errorConnection;
                loadingBubble.remove();
                const errorBubble = createAiBubble(errorMessage);
                elements.chatMessages.appendChild(errorBubble);
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
            }
        } finally {
            elements.sendBtn.style.display = 'block';
            elements.stopBtn.style.display = 'none';
            elements.clearBtnContainer.style.display = 'block';
        }
    }

    function getCurrentDateTimeString() { 
        const now = new Date(); 
        const year = now.getFullYear(); 
        const month = String(now.getMonth() + 1).padStart(2, '0'); 
        const day = String(now.getDate()).padStart(2, '0'); 
        const hours = String(now.getHours()).padStart(2, '0'); 
        const minutes = String(now.getMinutes()).padStart(2, '0'); 
        const seconds = String(now.getSeconds()).padStart(2, '0'); 
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`; 
    }

    function populateToolsMenu() { 
        if (!elements.toolsMenu) return; 
        elements.toolsMenu.innerHTML = ''; 
        slashCommands.forEach(cmd => { 
            const menuItem = document.createElement('div'); 
            menuItem.classList.add('suggestion-item-slash'); 
            menuItem.innerHTML = `<strong>${cmd.command}</strong><span>${cmd.description}</span>`; 
            menuItem.addEventListener('click', () => { 
                elements.questionInput.value = cmd.command + ' '; 
                elements.toolsMenu.classList.remove('visible'); 
                elements.toolsBtn.classList.remove('active'); 
                elements.questionInput.focus(); 
            }); 
            elements.toolsMenu.appendChild(menuItem); 
        }); 
    }

    function updateSendButtonState() { 
        if (elements.questionInput.value.trim() === '' && !currentImageData) { 
            elements.sendBtn.classList.add('disabled'); 
            elements.sendBtn.disabled = true; 
        } else { 
            elements.sendBtn.classList.remove('disabled'); 
            elements.sendBtn.disabled = false; 
        } 
    }

    function saveApiKey() { 
        const newKey = elements.apiKeyInput.value.trim(); 
        if (newKey) { 
            localStorage.setItem('miraiApiKey', newKey); 
            currentApiKey = newKey; 
            isUsingPublicApi = isPublicApiKey(currentApiKey);
            showCopyFeedback(uiStrings[currentLanguage].apiKeySaved); 
        } else { 
            localStorage.removeItem('miraiApiKey'); 
            currentApiKey = DEFAULT_API_KEY; 
            isUsingPublicApi = true;
            showCopyFeedback(uiStrings[currentLanguage].apiKeyRemoved); 
        }
        
        // Simpan custom persona jika aktif
        if (currentPersona === 'custom' && elements.customPersonaInput) {
            const customPrompt = elements.customPersonaInput.value.trim();
            if (customPrompt) {
                localStorage.setItem('miraiCustomPersona', customPrompt);
            } else {
                localStorage.removeItem('miraiCustomPersona');
            }
        }
        
        // Update persona prompt di chat history
        const personaPromptText = getPersonaPrompt(currentPersona);
        if (chatHistory.length > 0 && chatHistory[0].role === "user") {
            chatHistory[0].parts[0].text = personaPromptText;
            saveChatHistory();
        }
        
        showCopyFeedback('Pengaturan berhasil disimpan!');
    }

    function toggleApiVisibility() { 
        const input = elements.apiKeyInput; 
        const icon = elements.toggleApiKey; 
        if (input.type === 'password') { 
            input.type = 'text'; 
            icon.classList.remove('fa-eye'); 
            icon.classList.add('fa-eye-slash'); 
        } else { 
            input.type = 'password'; 
            icon.classList.remove('fa-eye-slash'); 
            icon.classList.add('fa-eye'); 
        } 
    }

    function updateConnectionStatus() { 
        if (navigator.onLine) { 
            elements.statusDot.classList.remove('offline'); 
            elements.statusDot.classList.add('online'); 
            elements.statusLabel.innerText = uiStrings[currentLanguage].onlineStatus; 
        } else { 
            elements.statusDot.classList.remove('online'); 
            elements.statusDot.classList.add('offline'); 
            elements.statusLabel.innerText = uiStrings[currentLanguage].offlineStatus; 
        } 
    }

    function updateUI() { 
        const lang = uiStrings[currentLanguage]; 
        elements.infoText.innerText = lang.infoText; 
        updateSettingsUI(); 
        updateDynamicPlaceholder(); 
        updateConnectionStatus(); 
    }

    function updateDynamicPlaceholder() { 
        const placeholders = uiStrings[currentLanguage].placeholderMessages; 
        const randomIndex = Math.floor(Math.random() * placeholders.length); 
        elements.questionInput.placeholder = placeholders[randomIndex]; 
    }

    function updateSettingsUI() { 
        const lang = uiStrings[currentLanguage]; 
        if (!lang) return; 
        elements.settingsHeaderTitle.innerText = lang.settingsHeaderTitle; 
        elements.settingsAppearanceTitle.innerText = lang.settingsAppearanceTitle; 
        elements.settingsThemeText.innerText = lang.settingsThemeText; 
        elements.themeLightOption.innerText = lang.themeLightOption; 
        elements.themeDarkOption.innerText = lang.themeDarkOption; 
        elements.settingsAITitle.innerText = lang.settingsAITitle; 
        elements.settingsPersonaText.innerText = lang.settingsPersonaText; 
        elements.personaFormalOption.innerText = lang.personaFormalOption; 
        elements.personaDefaultOption.innerText = lang.personaDefaultOption; 
        elements.personaCreativeOption.innerText = lang.personaCreativeOption; 
        elements.personaCustomOption.innerText = lang.personaCustomOption; 
        elements.customPersonaHint.innerText = lang.customPersonaHint; 
        elements.customPersonaInput.placeholder = lang.customPersonaPlaceholder; 
        elements.settingsAboutTitle.innerText = lang.settingsAboutTitle; 
        elements.settingsVersionText.innerText = lang.settingsVersionText; 
        elements.settingsAuthorText.innerText = lang.settingsAuthorText; 
        elements.githubLink.innerText = lang.githubLink; 
        elements.licenseLink.innerText = lang.licenseLink; 
        elements.helpLink.innerText = lang.helpLink; 
        elements.termsText.innerHTML = lang.termsText; 
        elements.settingsApiTitle.innerText = lang.settingsApiTitle; 
        elements.settingsApiText.innerText = lang.settingsApiText; 
        document.title = lang.pageTitle; 
        elements.saveApiBtn.innerText = lang.saveApiKeyBtn; 
        elements.apiKeyInput.placeholder = lang.apiKeyPlaceholder; 
    }

    function setTheme(theme) { 
        elements.body.classList.remove('light-theme', 'dark-theme'); 
        if (theme === 'light') { 
            elements.body.classList.add('light-theme'); 
        } else { 
            elements.body.classList.add('dark-theme'); 
        } 
        localStorage.setItem('miraiTheme', theme); 
        elements.themeSelect.value = theme; 
    }

    // --- HASH NAVIGATION UNTUK SETTINGS PANEL ---
    let isHashNavigating = false;

    function handleHashNavigation() {
        if (isHashNavigating) return;
        
        isHashNavigating = true;
        
        const currentHash = window.location.hash;
        const settingsPanel = document.getElementById('settingsPanel');
        
        console.log('üîó Hash navigation:', currentHash);
        
        if (currentHash === '#settings') {
            if (settingsPanel) {
                settingsPanel.style.display = 'flex';
                document.body.style.overflow = 'hidden';
                console.log('‚úÖ Settings panel opened');
            }
        } else {
            if (settingsPanel) {
                settingsPanel.style.display = 'none';
                document.body.style.overflow = '';
                console.log('‚ùå Settings panel closed');
            }
        }
        
        setTimeout(() => {
            isHashNavigating = false;
        }, 50);
    }

    function openSettings() {
        console.log('üéØ Opening settings...');
        
        if (window.location.hash === '#settings') return;
        
        sessionStorage.setItem('mainScrollPos', window.scrollY);
        
        history.pushState({ settings: true }, '', '#settings');
        
        handleHashNavigation();
    }

    function closeSettings() {
        console.log('üéØ Closing settings...');
        
        if (window.location.hash !== '#settings') return;
        
        history.back();
    }

    function handlePopState() {
        console.log('üîô Popstate event');
        setTimeout(handleHashNavigation, 10);
    }

    function setupHashNavigation() {
        console.log('üîß Setting up hash navigation...');
        
        const settingsPanel = document.getElementById('settingsPanel');
        if (!settingsPanel) {
            console.error('‚ùå Settings panel not found!');
            return;
        }
        
        settingsPanel.style.display = 'none';
        
        window.addEventListener('hashchange', handleHashNavigation);
        window.addEventListener('popstate', handlePopState);
        
        setTimeout(() => {
            console.log('üåê Initial hash:', window.location.hash);
            handleHashNavigation();
        }, 100);
        
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && window.location.hash === '#settings') {
                closeSettings();
            }
        });
        
        const settingsBtn = document.getElementById('settingsBtn');
        const backBtn = document.getElementById('backBtn');
        
        if (settingsBtn) {
            settingsBtn.addEventListener('click', openSettings);
        }
        
        if (backBtn) {
            backBtn.addEventListener('click', closeSettings);
        }
        
        console.log('‚úÖ Hash navigation setup complete');
    }

    function showSettingsPage() {
        openSettings();
    }

    function hideSettingsPage() {
        closeSettings();
    }

    window.addEventListener('beforeunload', () => {
        if (window.location.hash === '#settings') {
            history.replaceState(null, null, ' ');
        }
    });

    function toggleChatUI(active) { 
        if (active) { 
            elements.body.classList.add('chat-active'); 
            elements.inputContainer.classList.remove('centered'); 
            elements.inputContainer.classList.add('bottom'); 
            elements.logoContainer.classList.add('logo-hidden'); 
            elements.languageSwitcher.classList.add('lang-hidden'); 
            elements.infoText.style.display = 'block'; 
        } else { 
            elements.body.classList.remove('chat-active'); 
            elements.inputContainer.classList.remove('bottom'); 
            elements.inputContainer.classList.add('centered'); 
            elements.logoContainer.classList.remove('logo-hidden'); 
            elements.languageSwitcher.classList.remove('lang-hidden'); 
            elements.infoText.style.display = 'none'; 
        } 
    }

    function simulateLoading(duration) {
        const splashBar = document.querySelector('.loading-bar');
        
        if (duration === 0) {
            if (elements.splashScreen) {
                elements.splashScreen.style.display = 'none';
                elements.splashScreen.classList.add('hidden');
            }
            return;
        }

        if (!splashBar || !elements.splashScreen) return;

        const startTime = Date.now();
        const intervalId = setInterval(() => {
            const elapsedTime = Date.now() - startTime;
            let progress = (elapsedTime / duration) * 100;

            if (progress >= 100) {
                progress = 100;
                clearInterval(intervalId);
                setTimeout(() => {
                    elements.splashScreen.classList.add('hidden');
                    setTimeout(() => { elements.splashScreen.style.display = 'none'; }, 500);
                }, 500);
            }
            splashBar.style.width = `${progress}%`;
        }, 50);
    }

    function showSuggestions() { 
        const query = elements.questionInput.value.toLowerCase().trim(); 
        elements.suggestionBox.innerHTML = ''; 
        elements.suggestionBox.classList.remove('visible'); 
        if (query.startsWith('/')) { 
            const commandQuery = query.substring(1); 
            const matchingCommands = slashCommands.filter(cmd => cmd.command.substring(1).startsWith(commandQuery)); 
            if (matchingCommands.length > 0) { 
                elements.suggestionBox.classList.add('visible'); 
                matchingCommands.forEach(cmd => { 
                    const div = document.createElement('div'); 
                    div.classList.add('suggestion-item-slash'); 
                    div.innerHTML = `<strong>${cmd.command}</strong><span>${cmd.description}</span>`; 
                    div.addEventListener('click', () => { 
                        elements.questionInput.value = cmd.command + ' '; 
                        elements.suggestionBox.classList.remove('visible'); 
                        elements.questionInput.focus(); 
                    }); 
                    elements.suggestionBox.appendChild(div); 
                }); 
            } 
        } else { 
            if (query.length < 2) return; 
            const suggestions = Object.keys(faqDatabase) 
                .filter(key => key.toLowerCase().includes(query)) 
                .slice(0, 5); 
            if (suggestions.length > 0) { 
                elements.suggestionBox.classList.add('visible'); 
                suggestions.forEach(suggestion => { 
                    const div = document.createElement('div'); 
                    div.classList.add('suggestion-item'); 
                    div.innerText = suggestion; 
                    div.addEventListener('click', () => { 
                        elements.questionInput.value = suggestion; 
                        elements.suggestionBox.classList.remove('visible'); 
                        askAI(); 
                    }); 
                    elements.suggestionBox.appendChild(div); 
                }); 
            } 
        } 
    }

    function findSmartAnswer(question) { 
        const normalized = question.toLowerCase().trim(); 
        const sortedKeys = Object.keys(faqDatabase).sort((a, b) => b.length - a.length); 
        for (const key of sortedKeys) { 
            const normalizedKey = key.toLowerCase().replace("?", ""); 
            if (normalized.includes(normalizedKey)) return faqDatabase[key]; 
        } 
        return null; 
    }

    function typeWriterEffect(element, text, speed = 0.5) { 
        const parsedHtml = marked.parse(text); 
        let i = 0; 
        element.innerHTML = ''; 
        const tempElement = document.createElement('div'); 
        tempElement.innerHTML = parsedHtml; 
        const textToType = tempElement.innerText; 
        return new Promise(resolve => { 
            function type() { 
                if (i < textToType.length) { 
                    element.innerHTML += textToType.charAt(i); 
                    i++; 
                    setTimeout(type, speed); 
                } else { 
                    element.innerHTML = parsedHtml; 
                    resolve(); 
                } 
            } 
            type(); 
        }); 
    }

    function showLoading() { 
        const loadingBubble = document.createElement('div'); 
        loadingBubble.classList.add('chat-bubble', 'ai-bubble', 'typing-indicator', 'fade-in'); 
        loadingBubble.innerHTML = '<span></span><span></span><span></span>'; 
        elements.chatMessages.appendChild(loadingBubble); 
        return loadingBubble; 
    }

    function stopAI() {
        if (abortController) {
            abortController.abort();
            console.log("Response aborted.");
            elements.stopBtn.style.display = 'none';
            elements.sendBtn.style.display = 'block';
            elements.clearBtnContainer.style.display = 'block';
            const loadingBubble = document.querySelector('.typing-indicator');
            if (loadingBubble) loadingBubble.remove();
        }

        if (window.speechSynthesis.speaking) {
            window.speechSynthesis.cancel();
            document.querySelectorAll('.speak-btn').forEach(btn => {
                btn.classList.remove('fa-stop');
                btn.classList.add('fa-volume-up');
            });
        }
    }

    function handleSlashCommand(question) { 
        if (!question.startsWith('/')) { return null; } 
        const parts = question.split(' '); 
        const command = parts[0].toLowerCase(); 
        switch (command) { 
            case '/translate': { 
                const toIndex = parts.indexOf('to'); 
                if (toIndex === -1 || toIndex < 2) { return "Error: Invalid format. Use /translate [text] to [language]"; } 
                const textToTranslate = parts.slice(1, toIndex).join(' '); 
                const targetLanguage = parts.slice(toIndex + 1).join(' '); 
                return `Translate the following text to ${targetLanguage}: "${textToTranslate}"`; 
            } 
            case '/summarize': { 
                const textToSummarize = parts.slice(1).join(' '); 
                if (textToSummarize.length < 20) { return "Error: Please provide more text to summarize."; } 
                return `Provide a concise summary of the following text: "${textToSummarize}"`; 
            } 
            case '/rephrase': { 
                const asIndex = parts.indexOf('as'); 
                if (asIndex === -1 || asIndex < 2) { return "Error: Invalid format. Use /rephrase [text] as [tone]"; } 
                const textToRephrase = parts.slice(1, asIndex).join(' '); 
                const tone = parts.slice(asIndex + 1).join(' '); 
                return `Rephrase the following text in a ${tone} tone: "${textToRephrase}"`; 
            } 
            case '/ideate': { 
                const forIndex = parts.indexOf('for'); 
                if (forIndex === -1 || forIndex < 3 || isNaN(parseInt(parts[1]))) { return "Error: Invalid format. Use /ideate [number] ideas for [topic]"; } 
                const number = parts[1]; 
                const topic = parts.slice(forIndex + 1).join(' '); 
                return `Generate ${number} ideas for ${topic}. Present them as a numbered list.`; 
            } 
            case '/fix': { 
                const textToFix = parts.slice(1).join(' '); 
                if (!textToFix) { return "Error: Please provide text to fix. Use /fix [text]"; } 
                return `Proofread and correct any grammatical errors and spelling mistakes in the following text. Only provide the corrected text: "${textToFix}"`; 
            } 
            case '/explain': { 
                const likeIndex = parts.findIndex(part => part.toLowerCase() === "like"); 
                if (likeIndex === -1 || likeIndex < 2) { return "Error: Invalid format. Use /explain [concept] like I\'m [audience]"; } 
                const concept = parts.slice(1, likeIndex).join(' '); 
                const audienceIndex = parts.indexOf("I'm") > -1 ? parts.indexOf("I'm") : parts.indexOf("i'm"); 
                if (audienceIndex === -1 || audienceIndex <= likeIndex) { return "Error: Invalid audience format. Use \"like I'm ...\""; } 
                const audience = parts.slice(audienceIndex + 1).join(' '); 
                return `Explain the concept of "${concept}" as if you were talking to a ${audience}.`; 
            } 
            case '/code': { 
                const toIndex = parts.indexOf('to'); 
                if (toIndex === -1 || toIndex < 3) { return "Error: Invalid format. Use /code a [language] function to [description]"; } 
                const language = parts[2]; 
                const description = parts.slice(toIndex + 1).join(' '); 
                return `Write a code snippet in ${language} for the following task: "${description}". Provide only the code, enclosed in a markdown code block.`; 
            } 
            case '/search': { 
                const query = parts.slice(1).join(' '); 
                if (!query) { return "Error: Please provide a search query. Use /search [query]"; } 
                return `Search the web for information about "${query}". Provide a concise summary and, if possible, include relevant links.`; 
            } 
            default: return `Error: Unknown command "${command}". Try /translate or /summarize.`; 
        } 
    }

    function createAiBubble(text, useInnerHTML = true) {
        const bubble = document.createElement('div');
        bubble.classList.add('chat-bubble', 'ai-bubble', 'fade-in');
        bubble.setAttribute('data-raw-text', text);
        if (useInnerHTML) {
            bubble.innerHTML = `${marked.parse(text)}
                              <i class="fas fa-copy copy-btn" onclick="copyToClipboard(this)"></i>
                              <i class="fas fa-volume-up speak-btn" onclick="speakText(this)"></i>`;
        }
        return bubble;
    }

    // --- FUNGSI UNTUK TTS ---
    function getLangCodeForSpeech(lang) {
        if (lang === 'en-uk') return 'en-GB';
        if (lang === 'en') return 'en-US';
        if (lang === 'jp') return 'ja-JP';
        if (lang === 'id') return 'id-ID';
        return 'en-US';
    }

    function speakText(element) {
        const aiBubble = element.closest('.ai-bubble');
        const textToSpeak = aiBubble.getAttribute('data-raw-text');
        const icon = element;

        if (icon.classList.contains('fa-stop')) {
            window.speechSynthesis.cancel();
            return;
        }

        if (window.speechSynthesis.speaking) {
            window.speechSynthesis.cancel();
            document.querySelectorAll('.speak-btn').forEach(btn => {
                btn.classList.remove('fa-stop');
                btn.classList.add('fa-volume-up');
            });
        }

        if (!textToSpeak) return;

        const utterance = new SpeechSynthesisUtterance(textToSpeak);
        utterance.lang = getLangCodeForSpeech(currentLanguage);

        utterance.onstart = () => {
            icon.classList.remove('fa-volume-up');
            icon.classList.add('fa-stop');
        };

        utterance.onend = () => {
            icon.classList.remove('fa-stop');
            icon.classList.add('fa-volume-up');
        };

        utterance.onerror = (event) => {
            console.error('SpeechSynthesis Error:', event.error);
            icon.classList.remove('fa-stop');
            icon.classList.add('fa-volume-up');
        };

        window.speechSynthesis.speak(utterance);
    }

    function copyToClipboard(element) { 
        const aiBubble = element.closest('.ai-bubble'); 
        const textToCopy = aiBubble.getAttribute('data-raw-text'); 
        const formattedText = `${textToCopy}${uiStrings[currentLanguage].copySuffix}`; 
        const tempInput = document.createElement('textarea'); 
        tempInput.value = formattedText; 
        document.body.appendChild(tempInput); 
        tempInput.select(); 
        tempInput.setSelectionRange(0, 99999); 
        document.execCommand('copy'); 
        document.body.removeChild(tempInput); 
        showCopyFeedback(uiStrings[currentLanguage].copyFeedback); 
    }

    function showCopyFeedback(message) { 
        const feedbackDiv = document.createElement('div'); 
        feedbackDiv.innerText = message; 
        feedbackDiv.style.cssText = ` 
            position: fixed; 
            bottom: 150px; 
            left: 50%; 
            transform: translateX(-50%); 
            background-color: #444; 
            color: #fff; 
            padding: 10px 20px; 
            border-radius: 20px; 
            font-size: 14px; 
            z-index: 200; 
            opacity: 0; 
            transition: opacity 0.5s ease-in-out; 
        `; 
        document.body.appendChild(feedbackDiv); 
        setTimeout(() => { feedbackDiv.style.opacity = 1; }, 10); 
        setTimeout(() => { 
            feedbackDiv.style.opacity = 0; 
            setTimeout(() => feedbackDiv.remove(), 500); 
        }, 2000); 
    }

    function checkIndicatorPosition() { 
        const connectionStatus = document.getElementById('connectionStatus'); 
        if (!connectionStatus) return; 
        const indicatorRect = connectionStatus.getBoundingClientRect(); 
        const userBubbles = document.querySelectorAll('.user-bubble'); 
        let isOverlapping = false; 
        for (const bubble of userBubbles) { 
            const bubbleRect = bubble.getBoundingClientRect(); 
            const verticalOverlap = indicatorRect.bottom > bubbleRect.top && indicatorRect.top < bubbleRect.bottom; 
            const horizontalOverlap = indicatorRect.right > bubbleRect.left && indicatorRect.right < bubbleRect.right; 
            if (verticalOverlap && horizontalOverlap) { 
                isOverlapping = true; 
                break; 
            } 
        } 
        connectionStatus.classList.toggle('hidden-by-scroll', isOverlapping); 
    }

    // === DEBUG FUNCTIONS ===
    window.debugMirAI = {
        resetApiLimit: () => {
            MEDF_PROCESSOR.resetPublicApiBubbles();
            alert('Public API limit counter has been reset');
            location.reload();
        },
        getApiUsage: () => {
            const count = MEDF_PROCESSOR.countPublicApiBubbles();
            alert(`Public API usage: ${count} bubbles`);
            return count;
        },
        forcePublicApi: () => {
            currentApiKey = DEFAULT_API_KEY;
            isUsingPublicApi = true;
            localStorage.removeItem('miraiApiKey');
            alert('Switched to PUBLIC API for testing');
            location.reload();
        },
        checkApiStatus: () => {
            return {
                isPublic: isUsingPublicApi,
                apiKey: currentApiKey.substring(0, 10) + '...',
                bubbleCount: MEDF_PROCESSOR.countPublicApiBubbles(),
                limits: MEDF_PROCESSOR.PUBLIC_API_LIMITS
            };
        },
        // Fungsi debug baru untuk authenticity header
        validateMedfFile: async () => {
            try {
                const response = await fetch('config.medf');
                if (!response.ok) throw new Error('config.medf not found');
                
                const buffer = await response.arrayBuffer();
                const code = parseInt(prompt('Enter calculation code:', MEDF_PROCESSOR.DEFAULT_CODE));
                
                const apiKey = await MEDF_PROCESSOR.extractApiKeyFromConfig(buffer, code);
                alert(`‚úÖ File valid!\nAPI Key: ${apiKey.substring(0, 15)}...`);
            } catch (error) {
                alert(`‚ùå Error: ${error.message}`);
            }
        },
        checkSignature: () => {
            const headerText = MEDF_PROCESSOR.HEADER_TEXT;
            const headerCode = MEDF_PROCESSOR.generateHeaderCode(headerText);
            alert(`Header Text: ${headerText}\n\nHeader Code (first 40 chars):\n${headerCode.substring(0, 40)}...\n\nTotal length: ${headerCode.length} digits`);
        }
    };

    // --- EVENT LISTENER UTAMA ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log('üöÄ MirAI Initializing...');
        
        elements = { 
            questionInput: document.getElementById('questionInput'), 
            sendBtn: document.getElementById('sendBtn'), 
            stopBtn: document.getElementById('stopBtn'), 
            clearBtn: document.getElementById('clearBtn'), 
            clearBtnContainer: document.getElementById('clearBtnContainer'), 
            settingsBtn: document.getElementById('settingsBtn'), 
            chatMessages: document.getElementById('chatMessages'), 
            suggestionBox: document.getElementById('suggestionBox'), 
            body: document.body, 
            inputContainer: document.getElementById('inputContainer'), 
            logoContainer: document.querySelector('.logo-container'), 
            splashScreen: document.getElementById('splash-screen'), 
            langDropdown: document.getElementById('langDropdown'), 
            languageSwitcher: document.getElementById('languageSwitcher'), 
            infoText: document.getElementById('infoText'), 
            settingsPanel: document.getElementById('settingsPanel'),
            backBtn: document.getElementById('backBtn'), 
            themeSelect: document.getElementById('themeSelect'), 
            personaSelect: document.getElementById('personaSelect'), 
            customPersonaContainer: document.getElementById('customPersonaContainer'),
            customPersonaInput: document.getElementById('customPersonaInput'),
            customPersonaHint: document.getElementById('customPersonaHint'),
            settingsHeaderTitle: document.getElementById('settingsHeaderTitle'), 
            settingsAppearanceTitle: document.getElementById('settingsAppearanceTitle'), 
            settingsThemeText: document.getElementById('settingsThemeText'), 
            themeLightOption: document.getElementById('themeLightOption'), 
            themeDarkOption: document.getElementById('themeDarkOption'), 
            settingsAITitle: document.getElementById('settingsAITitle'), 
            settingsPersonaText: document.getElementById('settingsPersonaText'), 
            personaFormalOption: document.getElementById('personaFormalOption'), 
            personaDefaultOption: document.getElementById('personaDefaultOption'), 
            personaCreativeOption: document.getElementById('personaCreativeOption'), 
            personaCustomOption: document.getElementById('personaCustomOption'), 
            settingsAboutTitle: document.getElementById('settingsAboutTitle'), 
            settingsVersionText: document.getElementById('settingsVersionText'), 
            settingsAuthorText: document.getElementById('settingsAuthorText'), 
            githubLink: document.getElementById('githubLink'), 
            licenseLink: document.getElementById('licenseLink'), 
            statusDot: document.getElementById('statusDot'), 
            statusLabel: document.getElementById('statusLabel'), 
            apiKeyInput: document.getElementById('apiKeyInput'), 
            toggleApiKey: document.getElementById('toggleApiKey'), 
            saveApiBtn: document.getElementById('saveApiBtn'), 
            settingsApiTitle: document.getElementById('settingsApiTitle'), 
            settingsApiText: document.getElementById('settingsApiText'), 
            toolsBtn: document.getElementById('toolsBtn'), 
            toolsMenu: document.getElementById('toolsMenu'), 
            customConfirmOverlay: document.getElementById('customConfirmOverlay'), 
            customConfirmMessage: document.getElementById('customConfirmMessage'), 
            confirmBtnYes: document.getElementById('confirmBtnYes'), 
            confirmBtnNo: document.getElementById('confirmBtnNo'), 
            helpLink: document.getElementById('helpLink'), 
            termsText: document.getElementById('termsText'),
            exportBtn: document.getElementById('exportBtn'),
            importBtn: document.getElementById('importBtn'),
            importFileInput: document.getElementById('importFileInput'),
            uploadImageBtn: document.getElementById('uploadImageBtn'),
            imageInput: document.getElementById('imageInput'),
            imagePreviewContainer: document.getElementById('imagePreviewContainer'),
            imagePreview: document.getElementById('imagePreview'),
            removeImageBtn: document.getElementById('removeImageBtn')
        };

        console.log('‚úÖ Elements initialized:', Object.keys(elements).length, 'elements');

        // Pasang semua event listener
        elements.sendBtn.addEventListener('click', askAI);
        elements.stopBtn.addEventListener('click', stopAI);
        elements.clearBtn.addEventListener('click', showClearConfirmation);
        elements.settingsBtn.addEventListener('click', openSettings);
        elements.backBtn.addEventListener('click', closeSettings);
        elements.themeSelect.addEventListener('change', (e) => setTheme(e.target.value));
        elements.personaSelect.addEventListener('change', (e) => setPersona(e.target.value, true));
        elements.langDropdown.addEventListener('change', (event) => setLanguage(event.target.value, true));
        elements.questionInput.addEventListener('keydown', (event) => { 
            if (event.key === 'Enter' && !event.shiftKey) { 
                event.preventDefault(); 
                if (!elements.sendBtn.disabled) { 
                    askAI(); 
                } 
            } 
        });
        elements.questionInput.addEventListener('input', () => { 
            showSuggestions(); 
            updateSendButtonState(); 
            elements.questionInput.style.height = 'auto'; 
            elements.questionInput.style.height = elements.questionInput.scrollHeight + 'px'; 
        });
        elements.saveApiBtn.addEventListener('click', saveApiKey);
        elements.uploadImageBtn.addEventListener('click', () => elements.imageInput.click());
        elements.imageInput.addEventListener('change', handleImageUpload);
        elements.removeImageBtn.addEventListener('click', removeImage);
        elements.toggleApiKey.addEventListener('click', toggleApiVisibility);
        elements.confirmBtnYes.addEventListener('click', () => { 
            clearChat(); 
            hideClearConfirmation();
        });
        elements.confirmBtnNo.addEventListener('click', hideClearConfirmation);
        elements.toolsBtn.addEventListener('click', (event) => { 
            event.stopPropagation(); 
            const isActive = elements.toolsBtn.classList.contains('active'); 
            elements.suggestionBox.classList.remove('visible'); 
            if (!isActive) { 
                elements.toolsMenu.classList.add('visible'); 
                elements.toolsBtn.classList.add('active'); 
            } else { 
                elements.toolsMenu.classList.remove('visible'); 
                elements.toolsBtn.classList.remove('active'); 
            } 
        });
        document.addEventListener('click', (event) => { 
            if (elements.toolsMenu && !elements.toolsMenu.contains(event.target) && !elements.toolsBtn.contains(event.target)) { 
                elements.toolsMenu.classList.remove('visible'); 
                elements.toolsBtn.classList.remove('active'); 
            } 
        });
        window.addEventListener('scroll', checkIndicatorPosition, { passive: true });

        setupHashNavigation();

        // --- EXPORT/IMPORT HANDLER ---
        elements.exportBtn.addEventListener('click', () => {
            const allData = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                allData[key] = localStorage.getItem(key);
            }
            
            allData._metadata = {
                version: '2.12.0-Beta5',
                persona: currentPersona,
                language: currentLanguage,
                exportDate: new Date().toISOString(),
                model: model,
                format: 'mirai-backup-v2'
            };
            
            const exportType = confirm(
                "Select backup format:\n\n" +
                "[OK] - .medf file (ENCRYPTED with password & authenticity signature)\n" +
                "[CANCEL] - .mdf file (plain JSON)"
            ) ? 'encrypted' : 'plain';
            
            if (exportType === 'encrypted') {
                const password = prompt("Create a password for the encrypted backup:");
                if (!password || password.length < 4) {
                    alert("Password must be at least 4 characters!");
                    return;
                }
                
                processExportMEDF(allData, password)
                    .then(() => alert("‚úÖ .medf backup successfully created with authenticity signature!\nSave your password!"))
                    .catch(err => alert("‚ùå Failed: " + err.message));
                    
            } else {
                const blob = new Blob([JSON.stringify(allData, null, 2)], {type: "application/json"});
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = `MirAIBackup_${formattedDate}.mdf`;
                a.click();
                alert("‚úÖ .mdf backup successfully created!");
            }
        });

        elements.importBtn.addEventListener('click', () => {
            if (chatHistory.length > 2) {
                const confirmImport = confirm(
                    "‚ö†Ô∏è WARNING!\n\n" +
                    "You will import a backup. All current data will be REPLACED.\n\n" +
                    "‚Ä¢ Current chat history will be lost\n" +
                    "‚Ä¢ Settings will be changed according to the backup\n\n" +
                    "Continue?"
                );
                if (!confirmImport) return;
            }
            
            elements.importFileInput.click();
        });

        elements.importFileInput.addEventListener('change', async function(event) {
            console.log('üéØ Import triggered!');
            const file = event.target.files[0];
            if (!file) {
                console.log('‚ùå No file selected');
                return;
            }

            elements.importFileInput.value = '';
            
            console.log('üîÑ Importing file:', {
                name: file.name,
                size: file.size,
                type: file.type
            });
            
            if (file.name.endsWith('.medf')) {
                if (file.size < 50) {
                    alert('‚ùå The file is too small! It may be corrupted.');
                    return;
                }
                
                const password = prompt("üîí Enter the password to open the .medf file:");
                if (!password) {
                    alert('Import canceled.');
                    return;
                }
                
                try {
                    console.time('MEDF Decryption');
                    const data = await processImportMEDF(file, password);
                    console.timeEnd('MEDF Decryption');
                    
                    console.log('‚úÖ MEDF Decrypted:', {
                        keys: Object.keys(data),
                        hasChatHistory: !!data.miraiChatHistory
                    });
                    
                    restoreDataWithPersonaSync(data);
                    
                } catch (err) {
                    console.error('‚ùå MEDF Import Error:', err);
                    alert(`Failed to import .medf file:\n\n${err.message}\n\nMake sure:\n‚Ä¢ Password is correct\n‚Ä¢ File is not corrupted`);
                }
                return;
            }
            
            if (file.name.endsWith('.json') || file.name.endsWith('.mdf')) {
                try {
                    console.time('JSON Parse');
                    const text = await file.text();
                    
                    if (!text || text.trim().length === 0) {
                        alert('‚ùå File kosong!');
                        return;
                    }
                    
                    let data;
                    try {
                        data = JSON.parse(text);
                    } catch (parseError) {
                        alert('‚ùå The file is not a valid JSON format!\n\nMake sure to backup files from MirAI.');
                        return;
                    }
                    
                    console.timeEnd('JSON Parse');
                    console.log('‚úÖ JSON Parsed:', Object.keys(data));
                    
                    restoreDataWithPersonaSync(data);
                    
                } catch (e) { 
                    console.error('‚ùå JSON Import Error:', e);
                    alert(`Gagal import file:\n${e.message}\n\nFile mungkin rusak.`); 
                }
                return;
            }
            
            alert("‚ùå File format not supported!\n\nUse file with extension:\n‚Ä¢ .medf (encrypted backup with authenticity signature)\n‚Ä¢ .mdf (JSON backup)\n‚Ä¢ .json (JSON backup)");
        });

        // --- HASH NAVIGATION SETUP ---
        console.log('üîß Setting up hash navigation...');
        
        if (elements.settingsPanel) {
            elements.settingsPanel.style.display = 'none';
        }
        
        let hashChangeDebounce;
        window.addEventListener('hashchange', () => {
            clearTimeout(hashChangeDebounce);
            hashChangeDebounce = setTimeout(handleHashNavigation, 30);
        });
        
        window.addEventListener('popstate', () => {
            setTimeout(handleHashNavigation, 100);
        });
        
        if (window.location.hash && !window.location.hash.includes('settings')) {
            history.replaceState(null, null, ' ');
        }
        
        setTimeout(() => {
            console.log('üåê Initial hash:', window.location.hash);
            handleHashNavigation();
        }, 200);
        
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && window.location.hash === '#settings') {
                closeSettings();
            }
        });

        // Jalankan inisialisasi aplikasi - SEKARANG ASYNC
        initializeApp().then(() => {
            console.log('‚úÖ App initialized successfully');
            
            if (!isPWA) {
                if (elements.splashScreen) {
                    elements.splashScreen.style.display = 'flex';
                    simulateLoading(3000);
                }
            } else {
                console.log("üì± PWA Mode: Skip splash screen!");
            }

            updateConnectionStatus();
            populateToolsMenu();
            updateSendButtonState();

            window.addEventListener('beforeunload', () => {
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                }
                
                if (window.location.hash === '#settings') {
                    history.replaceState(null, null, ' ');
                }
            });
            
            console.log('üéâ MirAI initialization complete!');
        }).catch(error => {
            console.error('‚ùå Failed to initialize app:', error);
        });
    });

    // Event listener untuk online/offline status
    window.addEventListener('online', updateConnectionStatus);
    window.addEventListener('offline', updateConnectionStatus);
</script>
</body>

</html>
